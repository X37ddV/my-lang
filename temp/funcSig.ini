[FUNCTION_TYPE];不可修改
NUM=8
type0=引用数据函数
type1=逻辑判断函数
type2=辅助函数
type3=数学运算函数
type4=指令状态函数
type5=下单接口函数
type6=期权函数
type7=算法接口函数

[FUNCTION_ORDER]
function1=ABS 
function2=ABSF 
function2=ActualLeverage
function2=AL_BuyAvgPrice
function121=AL_BuyPosition
function121=AL_BuyProfitLoss
function121=AL_BuyRemainPosition
function121=AL_LastOffSetProfit
function121=AL_GetName
function121=AL_OffSetProfit
function121=AL_SellAvgPrice
function121=AL_SellPosition
function121=AL_SellProfitLoss
function121=AL_SellRemainPosition
function421=CallPut
function7=CEILING
function124=CheckPosition
function124=Counter
function6=CurrentTime
function6=CurrentServerTime
function6=data.State
function8=DateToStr
function8=Day
function9=Def_TickData
function8=Delta
function8=DYNINFO
function1=Exit
function1=ExpirationDate
function11=FloatToStr
function11=FLOOR
function59=F_Avprice
function18=F_BuyAvgPrice
function12=F_BuyPosition
function36=F_BuyRemainPosition
function60=F_BuyProfitLoss
function48=F_Close
function48=F_CurrentPos
function48=F_CurrentSigPos
function22=F_DealCode
function34=F_FreshSig
function34=F_GetCallCode
function52=F_High
function26=F_InitBuyVol
function26=F_InitCode
function28=F_InitSellVol
function30=F_InitBuyPrice
function32=F_InitSellPrice
function52=F_IsLastKline
function52=F_IsIdle
function52=F_IsTimeToKlineEnd
function53=F_LastOffSetProfit
function54=F_Low
function12=F_OffSetProfit 
function50=F_Open
function58=F_Opi
function24=F_Period 
function20=F_SellAvgPrice
function14=F_SellPosition
function37=F_SellRemainPosition
function60=F_SellProfitLoss
function36=F_Sig 
function36=F_SigCode
function36=F_SigGroup
function38=F_SigPrice
function39=F_SigTriggerPrice 
function40=F_SigVol 
function42=F_SigValid 
function44=F_SigTime 
function46=F_SigPos 
function56=F_Volume 
function60=F_Variant 
function60=Gamma
function60=GetDecimal
function60=GetPrivateProfileString
function60=GetMainCodeName
function60=GetSectionEndTime
function60=GLOBAL_VAR 
function61=Hour
function61=ImpliedVolatility 
function61=IntrinsicValue
function62=Itoa 
function64=LastOrderTime
function64=Leverage 
function66=MAX 
function66=MAX1 
function66=MessageOut 
function66=MIN 
function66=MIN1
function116=MinPrice
function116=Minute 
function116=Month 
function67=Offers
function67=OpenSecs
function122=POW
function61=PremiumRate
function68=Price
function68=Price1
function68=QuotState
function70=ReadFromFile
function70=ReadGlobal
function71=ReadGlobalF
function72=ReadGlobalStr
function72=Rho
function73=SamePeriod
function73=Second
function73=StrikePrice
function73=StrToFloat
function73=SubStr
function98=Theta
function98=TheoreticalValue
function74=Time
function123=Timer
function75=TimeToStr
function98=TimeValue
function107=T_AddBuyOpiTo
function108=T_AddSellOpiTo
function91=T_AllIsNoOrder
function91=T_BatchOrder
function86=T_BuyAvgPrice
function86=T_BuyOpiAvgPrice
function78=T_BuyPosition
function87=T_BuyProfitLoss
function87=T_BuyProfitLoss1
function79=T_BuyRemainPosition
function91=T_CancelAllOrder
function92=T_CloseAllOpi
function92=T_Deal
function92=T_Deal1
function99=T_DeleteOrder
function100=T_DeleteOrderByCode
function100=T_DeleteOrderByPrice
function106=T_DeleteOrderAll
function94=T_Equity
function93=T_FreeMargin
function93=T_Fee
function119=T_GetContractLimitVol
function119=T_GetFallLimit
function120=T_GetRiseLimit
function94=T_InitialEquity
function76=T_IsExchangeOpen
function11=T_IsNoOrder
function61=T_IsSHCode
function95=T_MaxOpen
function95=T_MarginRatio
function98=T_OffsetProfitLoss
function11=T_OrderMatchAvPrice
function11=T_OrderMatchVol
function96=T_OrderState
function98=T_OpenOrder
function98=T_ProfitLoss
function110=T_ReduceBuyOpiTo
function111=T_ReduceSellOpiTo
function90=T_SellAvgPrice
function86=T_SellOpiAvgPrice
function88=T_SellPosition
function91=T_SellProfitLoss
function91=T_SellProfitLoss1
function80=T_SellRemainPosition
function83=T_SHBuyPosition
function81=T_SHBuyRemainPosition
function85=T_SHSellPosition
function82=T_SHSellRemainPosition
function112=T_StgBuyVol
function113=T_StgSellVol
function113=T_TodayBuyPosition
function113=T_TodayBuyRemainPosition
function113=T_TodaySellPosition
function113=T_TodaySellRemainPosition
function98=Unit
function98=VAR_TICKDATA
function98=Vega
function102=Week
function102=WriteGlobal
function103=WriteGlobalF
function105=WriteGlobalStr
function105=WritePrivateProfileString
function105=WriteToFile
function105=Year
function106=#Get


[ABS]
type=3
test=1
explanation=取整数的绝对值
description=取整数的绝对值。\r\n用法：\r\nABS(Value) 返回Value的绝对值，Value是整数。\r\n\r\n注：\r\n1、正整数的绝对值是它本身；负整数的绝对值是它的相反数。\r\n2、若Value是浮点数，则该函数舍去小数部分。\r\n3、0的绝对值还是0；\r\n4、Value可以为变量；\r\n\r\n例1：\r\nX=ABS(-5.2);//X的值为5\r\n例2：\r\n\r\nVAR NN;\r\nVAR CODE;\r\n\r\nVOID MAIN()\r\n{\r\nCODE="IF1711";\r\nNN=ABS(Price(CODE,"NEW"));\r\nMessageOut(NN);//输出IF1711最新价整数部分的绝对值\r\n}
body=ABS()


[ABSF]
type=3
test=1
explanation=取浮点数的绝对值
description=取浮点数的绝对值。\r\n用法：\r\nABSF(ValueF) 返回ValueF的绝对值，ValueF是浮点数。\r\n\r\n注：\r\n1、正数的绝对值是它本身；\r\n2、负数的绝对值是它的相反数；\r\n3、0的绝对值还是0；\r\n4、ValueF可以为变量；\r\n\r\n例1：\r\nX=ABSF(-5.2);//X的值为5.2\r\n例2：\r\n\r\nVAR NN;\r\nVAR CODE;\r\n\r\nVOID MAIN()\r\n{\r\nCODE="IF1711";\r\nNN=ABSF(Price(CODE,"NEW"));\r\nMessageOut(NN);//输出IF1711最新价的绝对值\r\n}
body=ABSF()


[CurrentTime]
type=2
test=1
explanation=当前时间
description=返回当前时间。\r\n用法：\r\nCurrentTime() 返回当前时间（以总秒数表示）。\r\n例：\r\nVAR CurTime; \r\nCurTime=CurrentTime(); //定义一个变量CurTime,CurTime的值为当前时间。注意返回值是1970年1月1日至今的总秒数
body=CurrentTime()


[CurrentServerTime]
type=2
test=1
modifytime=2014-8-18
explanation=取最后一笔行情上的服务器时间
description=取最后一笔行情上的服务器时间。\r\n用法：\r\nCurrentServerTime("CODE")取CODE合约最后一笔行情上的服务器时间\r\n\r\n注：该函数需要在盘中使用，收盘后不能返回正确的时间。\r\n\r\n注：\r\n报价抬头项刷新，也会刷新该函数返回的服务器时间。\r\n\r\n例：\r\nVAR CurrentServerTime; \r\nCurrentServerTime=CurrentServerTime("m1501"); //定义一个变量CurrentServerTime,CurrentServerTime的值为豆粕1501最后一笔行情上的服务器时间。
body=CurrentServerTime()


[CEILING]
type=3
test=1
explanation=向上取整函数
description=向数值增大方向舍入。\r\n用法：\r\nCEILING(X)返回沿X数值增大方向最接近的整数。\r\n\r\n注：\r\nX可以为变量。\r\n例：CEILING(2.1);求得3\r\nCEILING(-8.8);求得-8。
body=CEILING( )


[DateToStr]
type=2
test=1
explanation=日期转换为字符串
description=日期转换为字符串。\r\n用法：\r\nDateToStr(nSec)把整型数值表示的时间nSec转换为字符串，nSec为时间的总秒数，返回的字符串格式为：YYMMDD\r\n例：\r\nMessageOut(DateToStr(CurrentTime() ) ); //输出当前日期
body=DateToStr( )


[Day]
type=2
test=1
modifytime=2014-03-07
explanation=返回日期数
description=Day(Time)返回当前时间对应的日期数。\r\n用法：\r\n1、参数Time为当前秒数，即可以为CurrentTime()，CurrentServerTime("CODE")，LastOrderTime()等\r\n2、Day(Time);返回值为：1-31\r\n\r\n例：\r\nVAR Day;\r\nVOID MAIN()\r\n{\r\n    Day=Day(CurrentServerTime("m1501"));\r\n    MessageOut(Day);\r\n}
body=Day( )


[DYNINFO]
type=2
test=0
explanation=获取某合约的60秒速涨、现增仓、现涨
description=获取某合约的60秒速涨、现增仓、现涨。\r\n用法：\r\nDYNINFO(Code, Type)\r\nCode:合约代码 Type:1,60秒速涨 2,现增仓 3,现涨\r\n例：\r\nMessageOut(DYNINFO("IF1309", 1));  //输出股指1309的60秒速涨。
body=DYNINFO( ,)


[Exit]
type=2
test=0
explanation=停止运行
description=停止运行。\r\n用法：\r\nExit()停止运行。\r\n例：Exit(); 停止运行。组件中写此函数表示只运行一次，组件将停止循环，请谨慎使用。\r\n\r\n说明：停止运行组件程序后，组件后续不再循环运行。
body=Exit()


[FLOOR]
type=3
test=1
explanation=向下取整函数
description=向数值减小方向舍入。\r\n用法：FLOOR(A)返回沿A数值减小方向最接近的整数。\r\n向下舍入。返回沿X数值减小方向最接近的整数。\r\n\r\n注：\r\nX可以为变量。\r\n\r\n例：\r\nFLOOR(2.1);求得2,FLOOR(-8.8);求得-9。
body=FLOOR( )


[F_BuyPosition]
type=4
test=0
modifytime=2014-08-05
explanation=模型某合约多头持仓
description=模型某合约多头持仓。\r\n用法：\r\nAA.F_BuyPosition()返回AA模组的多头持仓\r\n\r\n注：\r\n1、该函数前必须用AA.的形式来调用，其中AA为字符串变量或者模组名。该函数不能单独使用。\r\n2、只有在对应的模组源码中写入SETMODRUNTYPE(0)或者不写入SETMODRUNTYPE函数时，即按照模组中设置的信号执行方式出信号并下单时，该函数才可以取到值。\r\n\r\n例：\r\nVAR fmlBVol; \r\nfmlBVol=AA.F_BuyPosition(); //定义一个变量fmlBVol，fmlBVol为AA模组的多头持仓。
body=F_BuyPosition()


[F_BuyRemainPosition]
type=4
test=0
modifytime=2014-08-05
explanation=取模组多头可用持仓
description=取模组多头可用持仓。\r\n用法：\r\nAA.F_BuyRemainPosition 返回模组AA多头可用持仓\r\n\r\n注：\r\n1、该函数前必须用AA.的形式来调用，其中AA为字符串变量或者模组名。该函数不能单独使用。\r\n2、只有在对应的模组源码中写入SETMODRUNTYPE(0)或者不写入SETMODRUNTYPE函数时，即按照模组中设置的信号执行方式出信号并下单时，该函数才可以取到值。\r\n\r\n例：\r\nVAR fmlBVol; \r\nfmlBVol=AA.F_BuyRemainPosition();//定义一个变量fmlBVol，fmlBVol为模组AA的多头可用持仓。\r\n\r\n说明：可用持仓为抛除当前已挂平仓单的多头数量。
body=F_BuyRemainPosition()


[F_SellRemainPosition]
type=4
test=0
modifytime=2014-08-05
explanation=取模组空头可用持仓
description=取模组空头可用持仓。\r\n用法：\r\nAA.F_SellRemainPosition 返回模组AA空头可用持仓\r\n\r\n注：\r\n1、该函数前必须用AA.的形式来调用，其中AA为字符串变量或者模组名。该函数不能单独使用。\r\n2、只有在对应的模组源码中写入SETMODRUNTYPE(0)或者不写入SETMODRUNTYPE函数时，即按照模组中设置的信号执行方式出信号并下单时，该函数才可以取到值。\r\n\r\n例：\r\nVAR fmlSVol;\r\nfmlSVol=AA.F_SellRemainPosition(); 定义一个变量fmlSVol，fmlSVol为模组AA的空头可用持仓。\r\n\r\n说明：可用持仓为抛除当前已挂平仓单的空头数量。
body=F_SellRemainPosition()


[F_SellPosition]
type=4
test=0
modifytime=2014-08-05
explanation=模型某合约空头持仓
description=模型某合约空头持仓。\r\n用法：\r\nAA.F_SellPosition()返回模组AA的空头持仓\r\n\r\n注：\r\n1、该函数前必须用AA.的形式来调用，其中AA为字符串变量或者模组名。该函数不能单独使用。\r\n2、只有在对应的模组源码中写入SETMODRUNTYPE(0)或者不写入SETMODRUNTYPE函数时，即按照模组中设置的信号执行方式出信号并下单时，该函数才可以取到值。\r\n\r\n例：\r\nVAR fMLSVol;\r\nfmlSVol=AA.F_SellPosition(); 定义一个变量fmlSVol，fmlSVol为模组AA的空头持仓。
body=F_SellPosition()


[F_BuyAvgPrice]
type=4
test=0
modifytime=2014-08-05
explanation=模型某合约多头持仓成本价
description=模型某合约多头持仓成本价。\r\n用法：\r\nAA.F_BuyAvgPrice()返回模组AA多头持仓成本价\r\n\r\n注：\r\n1、该函数前必须用AA.的形式来调用，其中AA为字符串变量或者模组名。该函数不能单独使用。\r\n2、只有在对应的模组源码中写入SETMODRUNTYPE(0)或者不写入SETMODRUNTYPE函数时，即按照模组中设置的信号执行方式出信号并下单时，该函数才可以取到值。\r\n\r\n例：\r\nVAR price;\r\nprice=AA.F_BuyAvgPrice(); 定义一个变量price,price的值为模组AA多头持仓成本价
body=F_BuyAvgPrice()


[F_SellAvgPrice]
type=4
test=0
modifytime=2014-08-05
explanation=模型某合约空头持仓成本价
description=模型某合约空头持仓成本价。\r\n用法：\r\nAA.F_SellAvgPrice()返回模组AA空头持仓成本价\r\n\r\n注：\r\n1、该函数前必须用AA.的形式来调用，其中AA为字符串变量或者模组名。该函数不能单独使用。\r\n2、只有在对应的模组源码中写入SETMODRUNTYPE(0)或者不写入SETMODRUNTYPE函数时，即按照模组中设置的信号执行方式出信号并下单时，该函数才可以取到值。\r\n\r\n例：\r\nVAR price;\r\nprice=AA.F_SellAvgPrice() 定义一个变量price,price的值为模组AA空头持仓成本价
body=F_SellAvgPrice()


[F_DealCode]
type=4
test=0
modifytime=2014-08-05
explanation=取得当前模型的交易合约的合约编码
description=取得当前模型的交易合约的合约编码。\r\n用法：\r\nAA.F_DealCode()返回模组AA所交易合约的合约编码(以字符串类型返回)\r\n\r\n注：\r\n该函数前必须用AA.的形式来调用，其中AA为字符串变量或者模组名。该函数不能单独使用。\r\n\r\n例：\r\nVAR DealCode;\r\nDealCode=AA.F_DealCode();  //变量DealCode的内容为模组AA当前交易合约的合约编码.
body=F_DealCode()


[F_Period]
type=4
test=0
modifytime=2014-08-05
explanation=取得当前模型的周期
description=取得当前模型的周期。\r\n用法：\r\nAA.F_Period() 返回当前模组AA的周期(以字符串类型返回)\r\n\r\n注：\r\n1、该函数支持自定义周期使用，自定义秒周期、自定义分钟周期、自定义小时周期、自定义日周期分别返回custom_sec custom_min custom_hour custom_day\r\n2、该函数支持的周期数及其相应的返回值为\r\n（1）1分钟、3分钟、5分钟、10分钟、15分钟、30分钟依次返回min1  min3  min5  min10  min15  min30 \r\n（2）1小时、2小时、3小时、4小时分别返回hour1、hour2、hour3、hour4\r\n（3）1日、1周、1月、1季、1年分别返回day、week、month、quarter、year\r\n（4）量能周期返回vol\r\n（5）TICK返回tick\r\n3、该函数前必须用AA.的形式来调用，其中AA为字符串变量或者模组名。该函数不能单独使用。\r\n\r\n例：\r\n模组加载模型为：\r\nMA5:=MA(C,5);\r\nMA10:=MA(C,10);\r\nCROSSDOWN(MA5,MA10),SK;\r\nCROSS(MA5,MA10),BP;\r\nAUTOFILTER;\r\n\r\n加载在一分钟周期,模组名称为‘模组A’\r\n\r\n盘口模型运行池中加载运行：\r\nVAR AA,dd;\r\nGLOBAL_VAR BB;\r\nVAR CC;\r\nVOID MAIN()\r\n{\r\n   AA="模组A";\r\n   IF(BB==0)\r\n   {\r\n      CC=AA.F_Period();//变量CC的内容为当前模组AA所使用的周期.\r\n      MessageOut("开始回测");\r\n      MessageOut(CC);\r\n   BB=1;\r\n   }\r\n}
body=F_Period()


[F_InitBuyVol]
type=4
test=0
modifytime=2014-08-05
explanation=取已经初始化的多头持仓
description=取已经初始化的多头持仓。\r\n用法：\r\nAA.F_InitBuyVol() 返回模型初始化的多头持仓(整数).\r\n\r\n注：\r\n1、该函数前必须用AA.的形式来调用，其中AA为字符串变量或者模组名。该函数不能单独使用。\r\n2、只有在对应的模组源码中写入SETMODRUNTYPE(0)或者不写入SETMODRUNTYPE函数时，即按照模组中设置的信号执行方式出信号并下单时，该函数才可以取到值。\r\n\r\n例：\r\nVAR initBuyVol;//定义一个变量记录初始多头持仓\r\ninitBuyVol=AA.F_InitBuyVol();//取出初始多头持仓赋值给initBuyVol\r\n\r\n说明：读取仓位初始化窗口中的多头持仓数量
body=F_InitBuyVol

[F_InitSellVol]
type=4
test=0
modifytime=2014-08-05
explanation=取已经初始化的空头持仓
description=取已经初始化的空头持仓","取已经初始化的空头持仓。\r\n用法：\r\nAA.F_InitSellVol 返回模型初始化的空头持仓(整数).\r\n\r\n注：\r\n1、该函数前必须用AA.的形式来调用，其中AA为字符串变量或者模组名。该函数不能单独使用。\r\n2、只有在对应的模组源码中写入SETMODRUNTYPE(0)或者不写入SETMODRUNTYPE函数时，即按照模组中设置的信号执行方式出信号并下单时，该函数才可以取到值。\r\n\r\n例：\r\nVAR initSellVol;//定义一个变量记录初始空头持仓\r\ninitSellVol=AA.F_initSellVol();//取出初始空头持仓赋值给initSellVol\r\n\r\n说明：读取仓位初始化窗口中的空头持仓数量
body=F_initSellVol

[F_InitBuyPrice]
type=4
test=0
modifytime=2014-08-05
explanation=取已经初始化的多头持仓价格
description=取已经初始化的多头持仓价格。\r\n用法：\r\nAA.F_InitBuyPrice() 返回模型初始化的多头持仓价格.\r\n\r\n注：\r\n1、该函数前必须用AA.的形式来调用，其中AA为字符串变量或者模组名。该函数不能单独使用。\r\n2、只有在对应的模组源码中写入SETMODRUNTYPE(0)或者不写入SETMODRUNTYPE函数时，即按照模组中设置的信号执行方式出信号并下单时，该函数才可以取到值。\r\n\r\n例：\r\nVAR initBuyPrice;//定义一个变量记录初始多头持仓价格\r\ninitBuyPrice=AA.F_InitBuyPrice();//取出初始多头持仓价格赋值给initBuyPrice\r\n\r\n说明：读取仓位初始化窗口中的多头持仓价格
body=F_InitBuyPrice

[F_InitSellPrice]
type=4
test=0
modifytime=2014-08-05
explanation=取已经初始化的空头持仓价格
description=取已经初始化的空头持仓价格。\r\n用法：\r\nAA.F_InitSellPrice 返回模型初始化的空头持仓价格.\r\n\r\n注：\r\n1、该函数前必须用AA.的形式来调用，其中AA为字符串变量或者模组名。该函数不能单独使用。\r\n2、只有在对应的模组源码中写入SETMODRUNTYPE(0)或者不写入SETMODRUNTYPE函数时，即按照模组中设置的信号执行方式出信号并下单时，该函数才可以取到值。\r\n\r\n例：\r\nVAR initSellPrice;//定义一个变量记录初始空头持仓价格\r\ninitSellPrice=AA.F_InitSellPrice();//取出初始空头持仓价格赋值给initSellPrice\r\n\r\n说明：读取仓位初始化窗口中的空头持仓价格
body=F_InitSellPrice

[F_FreshSig]
type=4
test=0
modifytime=2014-08-05
explanation=刷新信号
description=刷新当前信号。\r\n用法：\r\nAA.F_FreshSig() 取一个新信号(如果模型已经发出了多个信号，取最近发出的信号，信号消失也是一种新信号)返回1表示取到新信号，返回0表示失败即已经没有新信号可取。取到新信号以后可以配合 AA.F_Sig, AA.F_SigVol, AA.F_SigValid, AA.F_SigTime, AA.F_SigPos使用\r\n\r\n注：\r\n该函数前必须用AA.的形式来调用，其中AA为字符串变量或者模组名。该函数不能单独使用。\r\n\r\n例：\r\nIF(AA.F_FreshSig()) //如果取得了新的信号
body=F_FreshSig()

[F_Sig]
type=4
test=0
modifytime=2014-08-05
explanation=取当前信号类型(BK|SK|BP|SP|BPK|SPK|CLOSEOUT|STOP)
description=取当前的信号(BK|SK|BP|SP|BPK|SPK|CLOSEOUT|STOP)。\r\n用法：\r\nAA.F_Sig() 返回当前的信号是什么类型(BK|SK|BP|SP|BPK|SPK|CLOSEOUT|STOP)\r\n\r\n注：\r\n该函数前必须用AA.的形式来调用，其中AA为字符串变量或者模组名。该函数不能单独使用，须与F_FreshSig()配合使用，在刷新信号之后才能取到值。\r\n\r\n例：\r\nIF(AA.F_Sig()==BPK && AA.F_SigValid()==1) //如果信号是BPK 且不是信号消失状态
body=F_Sig()

[F_SigPrice]
type=4
test=0
modifytime=2014-08-05
explanation=取当前信号出现时盘口对应的最新价格
description=取当前信号出现时盘口对应的最新价格。\r\n用法：\r\nAA.F_SigPrice() 取当前信号出现当时盘口对应的最新价格。\r\n\r\n注：\r\n1.该函数前必须用AA.的形式来调用，其中AA为字符串变量或者模组名。该函数不能单独使用。\r\n2.数据合约和交易合约不相同时，取信号出现时交易合约盘口对应的最新价格。\r\n\r\n例：\r\nIF(AA.F_SigPrice()>3500) //如果当前信号出现时盘口对应的最新价格大于3500 
body=F_SigPrice()


[F_SigVol]
type=4
test=0
modifytime=2014-08-05
explanation=取当前信号对应的手数
description=取当前信号对应的手数。\r\n用法：\r\nAA.F_SigVol() 取当前的信号对应的手数, 如果当前信号是BPK(5), 则返回5.\r\n\r\n注：\r\n该函数前必须用AA.的形式来调用，其中AA为字符串变量或者模组名。该函数不能单独使用。\r\n\r\n例：\r\nIF(AA.F_SigVol() == VarOpi) //如果信号的仓位等于变量VarOpi\r\n\r\n注：取当前信号对应的手数，并非默认下单手数。
body=F_SigVol()

[F_SigValid]
type=4
test=0
modifytime=2014-08-05
explanation=当前信号类型(发出或消失)
description=当前信号是发出的，还是消失的\r\n用法：\r\nAA.F_SigValid() 返回模型信号存在两种类型之一(信号发出，信号消失), 返回1表示信号发出, 返回0表示信号消失。\r\n注：\r\n1、该函数必须与AA.F_FreshSig()刷新信号函数同时使用。\r\n2、该函数前必须用AA.的形式来调用，其中AA为字符串变量或者模组名。该函数不能单独使用。\r\n\r\n例：\r\nIF(AA.F_FreshSig()==1)\r\n{\r\n      IF(AA.F_Sig()==BPK && AA.F_SigValid()==1)\r\n} //如果信号是BPK 且不是信号消失状态
body=F_SigValid()

[F_SigTime]
type=4
test=0
modifytime=2014-08-05
explanation=当前信号的发出时间
description=当前信号的发出时间。\r\n用法：\r\nAA.F_SigTime() 返回当前信号的发出时间(以总秒数表示)。\r\n注：\r\n1、该函数必须与AA.F_FreshSig()刷新信号函数同时使用。\r\n2、返回当前信号的发出时间，并非委托下单时间。\r\n3、该函数前必须用AA.的形式来调用，其中AA为字符串变量或者模组名。该函数不能单独使用。\r\n4、该函数返回时间为交易时间\r\n\r\n例：\r\nIF(AA.F_FreshSig()==1)\r\n{\r\n      IF(SamePeriod("m1009","min10",LastOrderTime(),AA.F_SigTime()) \r\n}//如果取得新信号的时间与上次交易的时间是同一个周期。
body=F_SigTime()

[F_SigPos]
type=4
test=0
modifytime=2014-08-05
explanation=当前信号在模型中是第几个有指令的语句
description=当前信号在模型中是第几个有指令的语句。\r\n用法：\r\nAA.F_SigPos() 如果当前信号是模型中第5个含信号的语句发出的，返回5\r\n\r\n注：\r\n该函数前必须用AA.的形式来调用，其中AA为字符串变量或者模组名。该函数不能单独使用。\r\n\r\n例：\r\nIF(AA.F_SigPos()==5) //如果当前信号是第5行发出的
body=F_SigPos()

[F_Close]
type=4
test=0
modifytime=2014-08-05
explanation=当前模型某根K线的收盘价
description=当前模型某根K线的收盘价。\r\n用法：\r\nAA.F_Close(n)返回倒数第 n+1 根K线的收盘价 \r\n\r\n注：\r\n该函数前必须用AA.的形式来调用，其中AA为字符串变量或者模组名。该函数不能单独使用。\r\n\r\n例：\r\nVAR c;\r\nc=AA.F_Close(0);//c为最后一根K线收盘价
body=F_Close( )

[F_Open]
type=4
test=0
modifytime=2014-08-05
explanation=当前模型某根K线的开盘价
description=当前模型某根K线的开盘价。\r\n用法：\r\nAA.F_Open(n)返回倒数第 n+1 根K线的开盘价 \r\n\r\n注：\r\n该函数前必须用AA.的形式来调用，其中AA为字符串变量或者模组名。该函数不能单独使用。\r\n\r\n例：\r\nVAR c;\r\nc=AA.F_Open(0);//c为最后一根K线开盘价
body=F_Open( )

[F_High]
type=4
test=0
modifytime=2014-08-05
explanation=当前模型某根K线的最高价
description=当前模型某根K线的最高价。\r\n用法：\r\nAA.F_High(n)返回倒数第 n+1 根K线的最高价 \r\n\r\n注：\r\n该函数前必须用AA.的形式来调用，其中AA为字符串变量或者模组名。该函数不能单独使用。\r\n\r\n例：\r\nVAR c;\r\nc=AA.F_High(0);//c为最后一根K线最高价
body=F_High( )

[F_Low]
type=4
test=0
modifytime=2014-08-05
explanation=当前模型某根K线的最低价
description=当前模型某根K线的最低价。\r\n用法：\r\nAA.F_Low(n)返回倒数第 n+1 根K线的最低价 \r\n\r\n注：\r\n该函数前必须用AA.的形式来调用，其中AA为字符串变量或者模组名。该函数不能单独使用。\r\n\r\n例：\r\nVAR c;\r\nc=AA.F_Low(0);//c为最后一根K线最低价
body=F_Low( )

[F_Volume]
type=4
test=0
modifytime=2014-08-05
explanation=当前模型某根K线的成交量
description=当前模型某根K线的成交量。\r\n用法：\r\nAA.F_Volume(n)返回倒数第 n+1 根K线的成交量 \r\n\r\n注：\r\n该函数前必须用AA.的形式来调用，其中AA为字符串变量或者模组名。该函数不能单独使用。\r\n\r\n例：\r\nVAR c;\r\nc=AA.F_Volume(0);//c为最后一根K线成交量
body=F_Volume( )

[F_Opi]
type=4
test=0
modifytime=2014-08-05
explanation=当前模型某根K线的持仓量
description=当前模型某根K线的持仓量。\r\n用法：\r\nAA.F_Opi(n)返回倒数第 n+1 根K线的持仓量 \r\n\r\n注：\r\n该函数前必须用AA.的形式来调用，其中AA为字符串变量或者模组名。该函数不能单独使用。\r\n\r\n例：\r\nVAR c;\r\nc=AA.F_Opi(0);//c为最后一根K线持仓量
body=F_Opi( )

[F_Avprice]
type=4
test=0
modifytime=2014-08-05
explanation=当前模型某根K线的均价
description=当前模型某根K线的均价。\r\n用法：\r\nAA.F_Avprice(n)返回倒数第 n+1 根K线的均价 \r\n\r\n注：\r\n该函数前必须用AA.的形式来调用，其中AA为字符串变量或者模组名。该函数不能单独使用。\r\n\r\n例：\r\nVAR c;\r\nc=AA.F_Avprice(0);//c为最后一根K线均价
body=F_Avprice( )

[F_Variant]
type=4
test=0
modifytime=2014-08-05
explanation=当前模型某变量在某根K线上的值
description=当前模型某变量在某根K线上的值。\r\n用法：\r\nAA.F_Variant(varname, n) 返回模型中变量varname在倒数第 n+1 根K线的值\r\nnvarname 变量名 类型为字符串\r\n\r\n注：\r\n该函数前必须用AA.的形式来调用，其中AA为字符串变量或者模组名。该函数不能单独使用。\r\n\r\n例：\r\n//example.trd\r\n...\r\nMA5:=MA(CLOSE,5); \r\n...\r\n//example.stg\r\nVAR ma5;\r\nma5=AA.F_Variant("MA5", 0);//c收盘价5个周期简单平均移动的最后一根K线值
body=F_Variant( , )

[F_BuyProfitLoss]
type=4
test=0
modifytime=2014-08-05
explanation=模组的多头盈亏
description=模组的多头盈亏。\r\n用法：\r\nAA.F_BuyProfitLoss()返回模组的多头盈亏\r\n\r\n注：\r\n1、该函数前必须用AA.的形式来调用，其中AA为字符串变量或者模组名。该函数不能单独使用。\r\n2、只有在对应的模组源码中写入SETMODRUNTYPE(0)或者不写入SETMODRUNTYPE函数时，即按照模组中设置的信号执行方式出信号并下单时，该函数才可以取到值。\r\n\r\n例：\r\nVAR BuyEarn;\r\nBuyEarn=AA.F_BuyProfitLoss();// 定义一个变量BuyEarn,BuyEarn的值为模组的多头盈亏。
body=F_BuyProfitLoss()

[F_SellProfitLoss]
type=4
test=0
modifytime=2014-08-05
explanation=模组的空头盈亏
description=模组的空头盈亏。\r\n用法：\r\nAA.F_SellProfitLoss()返回模组的空头盈亏\r\n\r\n注：\r\n1、该函数前必须用AA.的形式来调用，其中AA为字符串变量或者模组名。该函数不能单独使用。\r\n2、只有在对应的模组源码中写入SETMODRUNTYPE(0)或者不写入SETMODRUNTYPE函数时，即按照模组中设置的信号执行方式出信号并下单时，该函数才可以取到值。\r\n\r\n例：\r\nVAR BuyEarn;\r\nBuyEarn=AA.F_SellProfitLoss();// 定义一个变量BuyEarn,BuyEarn的值为模组的空头盈亏。
body=F_SellProfitLoss()

[T_IsSHCode]
type=1
test=0
explanation=判断合约是否是上海市场合约
description=T_IsSHCode(Code))判断合约是否是上海市场合约。\r\n\r\n用法：\r\nCode为合约代码，\r\nT_IsSHCode(Code)返回值：\r\n为-1 异常 \r\n为1 表示是上海市场合约\r\n为 0 表示不是上海市场合约\r\n\r\n注：\r\n1、上海市场合约包括上期所(SHFE)合约和上期能源(INE)合约。\r\n2、该函数不支持回测。\r\n\r\n例：\r\nIF(T_IsSHCode(F_DealCode())==1)\r\n{\r\nT_Deal(F_DealCode(), 0, 2, 5,0); \r\n}\r\n如果合约为上海合约，则执行买平今的操作
body=T_IsSHCode( )


[Itoa]
type=2
test=1
explanation=数字转换为字符
description=数字转换为字符。\r\n用法：\r\nItoa(Value)将Value转换成字符串，Value的为整型数值\r\n例：\r\nVAR str; str="数字"+Itoa(5); //str的值为"数字5"
body=Itoa( )

[LastOrderTime]
type=5
test=1
explanation=最后一次下单的时间
description=最后一次下单的时间。\r\n用法：\r\nLastOrderTime()返回最后一次下单的时间，以总秒数表示\r\n例：\r\nIF( ( CurrentTime()-LastOrderTime() )>= 300)如果距离上次下单时间超过5分钟\r\n\r\n注：返回本算法模型最后一次下单的委托时间。（撤单不算）。
body=LastOrderTime()

[MessageOut]
type=2
test=1
explanation=输出内容
description=输出内容。\r\n用法：MessageOut(Content),输出Content的内容。注意：Content可以是字符串也可以是数字
body=MessageOut( )

[Offers]
type=0
test=1
modifytime=2014-09-03
explanation=某合约的买卖盘报价或买卖量
description=某合约的买卖盘报价或买卖量。\r\n用法：\r\nOffers(Code,strContent) 返回某合约的买卖盘报价或买卖量Code为某合约的合约代码(字符串), strContent为所要取得内容,可选以下内容\r\n"bid1","bid2","bid3","bid4","bid5",分别表示买1价-买5价\r\n"ask1","ask2","ask3","ask4","ask5",分别表示卖1价-卖5价\r\n"bidvol1","bidvol2","bidvol3","bidvol4","bidvol5",分别表示买1量-买5量\r\n"askvol1","askvol2","askvol3","askvol4","askvol5",分别表示卖1量-卖5量\r\n\r\n例：\r\nGLOBAL_VAR bid1,code;\r\nVOID MAIN()\r\n{\r\ncode = "AU1606";\r\nIF(Offers(code,"bid1")==0)//bid1为au1606的当前买1价\r\n{\r\nRETURN;\r\n}\r\nELSE\r\nbid1=Offers("m1009","bid1");\r\nMessageOut(bid1); \r\n}\r\n//注：当取买卖盘报价时，在特殊情况下取不到有效值。如遇不活跃的合约，或是遇涨跌停等情况。该例就对有效值进行了一下判断
body=Offers( , )

[ReadGlobal]
type=2
test=1
explanation=读取注册的变量(整型)
description=返回已注册的整型变量的值\r\n用法：ReadGlobal(strName);返回注册的strName的值,strName为已注册的整型变量的注册名称(字符串)。如果strName未被注册过，返回0\r\n例：\r\nWriteGlobal("limit",20);\r\nVAR limitValue;\r\nlimitValue=ReadGlobal("limit");limitValue的值为20。
body=ReadGlobal( )

[ReadGlobalF]
type=2
test=1
explanation=读取注册变量(浮点数)
description=返回已注册的浮点型变量的值\r\n用法：ReadGlobalF(strNameF);返回注册的strNameF的值,strNameF为已注册的浮点型变量的注册名称(字符串)，如果strNameF未被注册过，返回0.0f\r\n例：\r\nWriteGlobalF("Rate",0.5);\r\nVAR fRate;\r\nfRate=ReadGlobal(Rate);fRate的值为0.5。
body=ReadGlobalF( )

[ReadGlobalStr]
type=2
test=1
explanation=读取注册变量(字符串)
description=返回已注册的字符串变量的值\r\n用法：ReadGlobalStr(NameStr);返回注册的NameStr的值,NameStr为已注册的字符串变量的注册名称。如果NameStr未被注册过，返回""(空字符串)\r\n例：\r\nWriteGlobalStr("showStr","上升");\r\nVAR str;\r\nstr=ReadGlobal(showStr);//str的值为"上升"。
body=ReadGlobalStr( )

[SamePeriod]
type=1
test=1
explanation=判断两个时间是否是同一个周期
description=判断两个时间是否是同一个周期。\r\n用法：\r\nSamePeriod(Code,PeriodStr,T1,T2)如果T1,T2是同一个周期返回1，否则返回0,Code:合约的合约代码，PeriodStr可以取以下值的其中之一："min1","min3","min5","min10","min15","min30","1hour","3hour","8hour","1day","week","month"，T1和T2是以总秒数表示的时间\r\n例：\r\nIF(SamePeriod("m1009","min10",LastOrderTime(),Time("09:00:00"))合约为m1009，周期为10分钟情况下，如果最后一次下单时间与09:00:00在同一个周期内
body=SamePeriod( , , , )

[Time]
type=2
test=1
explanation=转换字符串为时间
description=转换字符串为时间。\r\n用法：\r\nTime(strTime) 转换字符串strTime为时间(以总秒数表示)，strTime的格式应为HH:MM:SS，其中0<=HH<24,0<=MM<60,0<=SS<60,如果不满足此条件，返回0\r\n例：\r\ntime:Time("09:15:00") 
body=Time( )

[TimeToStr]
type=2
test=1
explanation=时间转换为字符串
description=时间转换为字符串。\r\n用法：\r\nTimeToStr(nSec) 把整型数值表示的时间nSec转换为字符串，nSec为时间的总秒数，返回的字符串格式为：HH:MM:SS\r\n例：\r\nMessageOut(TimeToStr(CurrentTime())),输出当前时间
body=TimeToStr( )

[T_IsExchangeOpen]
type=5
TEST=1
explanation=查询合约所属交易所的状态
description=查询合约所属交易所的状态。\r\n用法：\r\nT_IsExchangeOpen(Code)返回合约Code所属的交易所的开闭盘状态,开盘返回1，闭盘返回0，集合竞价时间返回2，查询失败返回-1。\r\n\r\n注：\r\n1、集合竞价最后一分钟为撮合时间不能交易，算作闭盘返回0\r\n2、内盘、股票合约支持开闭盘状态判断；外盘合约不支持开闭盘状态判断，该函数返回无效值。\r\n\r\n例：\r\nVAR Status;\r\nStatus=T_IsExchangeOpen("m1009"); //Status为合约m1009所属交易所当前的开闭盘状态。当Status为1时，说明该交易所开盘；当Status为0时，说明该交易所闭盘；当Status为2时，说明该交易所处于集合竞价时间；当Status为-1时，说明当前查询失败。\r\n2、该函数在回测的时候返回值为1。
body=T_IsExchangeOpen( )

[T_BuyPosition]
type=5
test=0
explanation=交易系统某合约多头持仓
description=交易系统某合约多头持仓。\r\n用法：\r\nT_BuyPosition(Code)返回交易系统中合约Code的多头持仓,Code为某合约的合约代码。\r\n\r\n注：\r\n该函数不支持回测。\r\n例：\r\nVAR BuyVol;\r\nBuyVol=T_BuyPosition("m1009"); //BuyVol为交易系统中合约代码为m1009的合约的多头持仓。
body=T_BuyPosition( )

[T_BuyRemainPosition]
type=5
test=0
explanation=交易系统某合约多头可用持仓
description=交易系统某合约多头可用持仓。\r\n用法：\r\nT_BuyRemainPosition(Code)返回交易系统中合约Code的多头持仓,Code为某合约的合约代码。\r\n\r\n注：\r\n该函数不支持回测。\r\n例：\r\nVAR BuyRemainVol;\r\nBuyRemainVol=T_BuyRemainPosition("m1009"); //BuyRemainVol为交易系统中合约代码为m1009的合约的多头可用持仓。
body=T_BuyRemainPosition( )

[T_SellRemainPosition]
type=5
test=0
explanation=交易系统某合约空头可用持仓
description=交易系统某合约空头可用持仓。\r\n用法：\r\nT_SellRemainPosition(Code)返回交易系统中合约Code的空头持仓,Code为某合约的合约代码。\r\n\r\n注：\r\n该函数不支持回测。\r\n例：\r\nVAR SellRemainVol;\r\nSellRemainVol=T_SellRemainPosition("m1009"); //SellRemainVol为交易系统中合约代码为m1009的合约的空头可用持仓。
body=T_SellRemainPosition( )

[T_SHBuyRemainPosition]
type=5
test=0
explanation=交易系统上海市场某合约多头可用持仓
description=交易系统上海市场某合约多头可用持仓。\r\n用法：\r\nT_SHBuyRemainPosition(code,Type)返回上海市场交易系统中合约Code的多头可用持仓,Code为某合约的合约代码。Type:0 今仓 1 老仓\r\n\r\n注：\r\n1、上海市场合约包括上期所(SHFE)合约和上期能源(INE)合约。\r\n2、该函数不支持回测。\r\n例：\r\nVAR BuyRemainVol;\r\nBuyRemainVol=T_SHBuyRemainPosition("ru1009",0); //BuyRemainVol为交易系统中合约代码为ru1009的合约的多头今仓可用持仓。
body=T_SHBuyRemainPosition( )

[T_SHSellRemainPosition]
type=5
test=0
explanation=交易系统上海市场某合约空头可用持仓
description=交易系统上海市场某合约空头可用持仓。\r\n用法：\r\nT_SHSellRemainPosition(Code,Type)返回上海市场交易交易系统中合约Code的空头可用持仓,Code为某合约的合约代码。Type:0 今仓 1 老仓\r\n\r\n注：\r\n1、上海市场合约包括上期所(SHFE)合约和上期能源(INE)合约。\r\n2、该函数不支持回测。\r\n例：\r\nVAR SellRemainVol;\r\nSellRemainVol=T_SHSellRemainPosition("ru1009",0); //SellRemainVol为交易系统中合约代码为ru1009的合约的空头今仓可用持仓。
body=T_SHSellRemainPosition( )

[T_SHBuyPosition]
type=5
test=0
explanation=交易系统上海市场某合约多头持仓
description=交易系统上海市场某合约多头持仓。\r\n用法：\r\nT_SHBuyPosition(code,Type)返回上海市场交易系统中合约Code的多头持仓,Code为某合约的合约代码。Type:0 今仓 1 老仓\r\n\r\n注：\r\n1、上海市场合约包括上期所(SHFE)合约和上期能源(INE)合约。\r\n2、该函数不支持回测。\r\n例：\r\nVAR BuyVol;\r\nBuyVol=T_SHBuyPosition("ru1009",0); //BuyVol为交易系统中合约代码为ru1009的合约的多头今仓持仓。
body=T_SHBuyPosition( )


[T_SHSellPosition]
type=5
test=0
explanation=交易系统上海市场某合约空头持仓
description=交易系统上海市场某合约空头持仓。\r\n用法：\r\nT_SHSellPosition(Code,Type)返回上海市场交易交易系统中合约Code的空头持仓,Code为某合约的合约代码。Type:0 今仓 1 老仓\r\n\r\n注：\r\n1、上海市场合约包括上期所(SHFE)合约和上期能源(INE)合约。\r\n2、该函数不支持回测。\r\n例：\r\nVAR SellVol;\r\nSellVol=T_SHSellPosition("ru1009",0); //SellVol为交易系统中合约代码为ru1009的合约的空头今仓持仓。
body=T_SHSellPosition( )

[T_BuyAvgPrice]
type=5
test=0
explanation=交易系统某合约多头开仓均价
description=交易系统某合约多头开仓均价。\r\n用法：T_BuyAvgPrice(Code)返回交易系统合约Code的多头开仓均价,Code为某合约合约代码。\r\n\r\n注：\r\n1、股票合约返回成本价（包含手续费成本）。\r\n该函数不支持回测。\r\n例：\r\nVAR BuyPrice; BuyPrice=T_BuyAvgPrice("m1009");// 定义一个变量BuyPrice,BuyPrice的值为交易系统合约m1009多头开仓均价
body=T_BuyAvgPrice( )

[T_BuyProfitLoss]
type=5
test=0
explanation=交易系统某合约的多头盈亏
description=交易系统某合约的多头盈亏。\r\n用法：\r\nT_BuyProfitLoss(code)返回交易系统合约code的多头盈亏\r\n\r\n注：\r\n该函数不支持回测。\r\n例：\r\nVAR BuyEarn;\r\nBuyEarn=T_BuyProfitLoss("m1009");// 定义一个变量BuyEarn,BuyEarn的值为交易系统合约m1009的多头盈亏
body=T_BuyProfitLoss( )

[T_SellPosition]
type=5
test=0
explanation=交易系统某合约空头持仓
description=交易系统某合约空头持仓。\r\n用法：\r\nT_SellPosition(Code)返回交易系统中合约Code的空头持仓,Code为某合约的合约代码。\r\n\r\n注：\r\n该函数不支持回测。\r\n例：\r\nVAR SellVol;\r\nSellVol=T_SellPosition("m1009");// SVol为交易系统中合约代码为m1009的合约的空头持仓。
body=T_SellPosition( )

[T_SellAvgPrice]
type=5
test=0
explanation=交易系统某合约空头开仓均价
description=交易系统某合约空头开仓均价。\r\n用法：T_SellAvgPrice(code)返回交易系统合约code的空头开仓均价,code为某合约合约代码。\r\n\r\n注：\r\n该函数不支持回测。\r\n例：\r\nVAR SellPrice;\r\nSellPrice=T_SellAvgPrice("m1009");// 定义一个变量SellPrice,SellPrice的值为交易系统合约m1009空头开仓均价
body=T_SellAvgPrice( )

[T_SellProfitLoss]
type=5
test=0
explanation=交易系统某合约的空头盈亏
description=交易系统某合约的空头盈亏。\r\n用法：\r\nT_SellProfitLoss(code)返回交易系统合约code的空头盈亏\r\n\r\n注：\r\n该函数不支持回测。\r\n例：\r\nVAR SellEarn;\r\nSellEarn=T_SellProfitLoss("m1009") 定义一个变量SellEarn,SellEarn的值为交易系统合约m1009的空头盈亏
body=T_SellProfitLoss( )

[T_Deal]
type=5
test=1
explanation=发出委托
description=发出委托。\r\n用法：\r\nT_Deal(Code,bs,kp,vol,price),发出委托。Code(字符串):合约编码，bs(整数0，1):0 买 1 卖 ，kp(整数0，1，2):0 开 1平 2平今 Vol(整数)：下单手数，Price(整数或小数):下单价格，0为对价 返回唯一委托标识OrderID(字符串)\r\n\r\n注：\r\n该函数不支持回测。\r\n例：\r\nVAR orderID=T_Deal("m1009", 0, 0, 5, 2900); 发出委托：m1009 买开5手 限价2900
body=T_Deal( , , , , )

[T_FreeMargin]
type=5
test=1
explanation=可用资金
description=可用资金。\r\n用法T_FreeMargin(Type), 返回可用资金。　Type(整数 0, 1, 2) 0期货 1股票 2外盘，返回可用资金数(小数)\r\n\r\n注：\r\n该函数在回测时，只考虑回测设置的资金。\r\n例：\r\nVAR margin;\r\nmargin=T_FreeMargin(0); //返回当前期货帐户的可用资金数
body=T_FreeMargin( )

[T_Equity]
type=5
test=1
explanation=权益
description=权益。\r\n用法T_Equity(Type), 返回权益。　Type(整数 0, 1 2) 0期货 1股票 2外盘，返回权益(小数)\r\n\r\n注：\r\n该函数在回测时，只考虑回测设置的资金。\r\n例：\r\nVAR margin;\r\nmargin=T_Equity(0); //返回当前期货帐户的权益数
body=T_Equity( )

[T_Fee]
type=5
test=0
explanation=取交易里的手续费
description=取交易里的手续费。\r\n用法T_Fee(Type),返回交易里的手续费。Type(整数 0, 1 2) 0期货 1股票 2外盘，返回手续费(小数)\r\n\r\n注：\r\n该函数不支持回测。\r\n例：\r\nVAR margin;\r\nmargin=T_Fee(0);//返回交易中的手续费。
body=T_Fee( )

[T_MaxOpen]
type=5
test=0
explanation=某品种最大可开仓手数
description=某品种最大可开仓手数。\r\n用法：\r\nT_MaxOpen(Code, margin, bs),某品种最大可开仓手数。Code(字符串):合约编码，margin(比例为小数形式)：保证金比例或保证金,国内期货合约取保证金比例，外盘期货合约取每手保证金　bs(整数0,1):0 买 1 卖　返回该品种在当前可用资金，当前价格下的可开仓手数(整数)\r\n\r\n注：\r\n该函数不支持回测。\r\n例1：\r\nVAR vol;\r\nvol=T_MaxOpen("m2009", 0.1, 0);  //变量vol为m2009 的　在保证金比例为0.1 下的可开仓手数\r\n例2：\r\nVAR vol;\r\nVOID MAIN()\r\n{\r\nvol=T_MaxOpen("BRNN0", 8252, 0); \r\nMessageOut(vol);\r\n}
body=T_MaxOpen( , , )

[T_OrderState]
type=5
test=1
explanation=查询委托状态
description=查询委托状态。\r\n用法：\r\nT_OrderState(OrderID)根据委托唯一标识OrderID(字符串)查委托状态,返回值含义：-1查询失败；0挂单；1成交；2被撤单；3部分成交；4表示委托发送成功了，还没有回来应答，不能进行操作，需要等应答回来再进行其它操作；6委托报送；7委托失败，即委托列表状态中的“废单”；13委托已发；14待撤;\r\n例：\r\nIF(T_OrderState(X)==0) 如果委托X是挂单
body=T_OrderState( )

[T_OpenOrder]
type=5
test=1
explanation=查询挂单数量
description=查询挂单数量。\r\n用法：\r\nT_OpenOrder(Code,Type)返回未成交委托数量,Code:交易编码,Type:0所有方向;1买开;2卖平;3卖开;4买平\r\n例：\r\nIF(CurrentTime()-LastOrderTime() >= 300  && T_OpenOrder("IF1909",1)>0) \r\nT_DeleteOrderByCode("IF1909",1)  //如果距离上次下单超过5分钟，且存在买开挂单,撤掉剩余买开委托合约X的未成交委托数量
body=T_OpenOrder( , )

[T_OffsetProfitLoss]
type=5
test=0
explanation=平仓盈亏
description=平仓盈亏。\r\n用法：\r\nT_OffsetProfitLoss(Type)返回平仓盈亏。Type(整数 0,1,2) 0期货 1股票 2外盘，返回平仓盈亏(小数)\r\n\r\n注：\r\n该函数不支持回测。\r\n例：\r\nVAR margin;\r\nmargin=T_OffsetProfitLoss( );//返回平仓盈亏。
body=T_OffsetProfitLoss( )

[T_DeleteOrder]
type=5
test=1
explanation=委托撤单
description=委托撤单。\r\n用法：\r\nT_DeleteOrder(OrderID)根据委托唯一标识orderID(字符串)撤单，返回0表示可以撤单，并发出撤单委托；返回-1表示撤单失败或者已经成交不能进行撤单；返回-5 表示查询失败；\r\n\r\n注：\r\n该函数不支持回测。\r\n例：\r\nIF(T_DeleteOrder(orderID)!=0)//如果撤单失败\r\nIF(T_DeleteOrder(orderID)==-1)//如果撤单失败或者已经成交不能进行撤单\r\n\r\n注：OrderID可参考T_Deal()函数
body=T_DeleteOrder( )

[T_DeleteOrderByCode]
type=5
test=0
explanation=委托撤单(通过合约代码)
description=委托撤单(通过合约代码)。\r\n用法：\r\nT_DeleteOrderByCode(Code,Type)委托撤单。Code:合约代码(字符串)Type:0所有方向;1买开;2卖平;3卖开;4买平 返回0撤单发出成功，返回其它失败\r\n\r\n注：\r\n1、该函数不支持回测。\r\n例：\r\nT_DeleteOrderByCode("ru1009",2)撤单橡胶1009的卖平委托 
body=T_DeleteOrderByCode( , )

[WriteGlobal]
type=2
test=1
explanation=注册变量(整型)
description=注册一个整型变量。\r\n用法：\r\nWriteGlobal(Name,Value)。Name为整型变量的注册名称(字符串)，Value为整型变量的值\r\n例：\r\nWriteGlobal("Period",5) 注册一个整型变量,注册名称为"Period"，值为5。
body=WriteGlobal( , )

[WriteGlobalF]
type=2
test=1
explanation=注册变量(浮点型)
description=注册一个浮点形变量\r\n用法：\r\nWriteGlobal(NameF,ValueF)。NameF为浮点形变量的注册名称(字符串)，ValueF为浮点形变量的值\r\n例：\r\nWriteGlobalF("Rate",0.5) 注册一个浮点形变量，注册名称为"Rate"，值为0.5。
body=WriteGlobalF( , )

[WriteGlobalStr]
type=2
test=1
explanation=注册变量(字符串)
description=注册一个字符串变量\r\n用法：WriteGlobalStr(NameStr,ValueStr)。NameStr为字符串变量的注册名称(字符串)，ValueStr为字符串变量的值\r\n例：\r\nWriteGlobalStr("showStr","上升") 注册一个字符串变量,注册名称为"showStr"，值为"上升"。
body=WriteGlobalStr( , )

[T_DeleteOrderAll]
type=5
test=0
explanation=撤掉所有未成交委托
description=撤掉所有未成交委托。\r\n用法：\r\nT_DeleteOrderAll()撤掉所有该模型相关的未成交委托单，返回0撤单发出成功，返回其它失败\r\n\r\n注：\r\n该函数不支持回测。\r\n例：\r\nIF(T_DeleteOrderAll()!=0)//如果撤单失败
body=T_DeleteOrderAll()

[T_AddBuyOpiTo]
type=5
test=0
explanation=买开达到指定目标量
description=根据当前成交的量采用买开的手段达到把仓位增加某一数值的目的。\r\n用法：\r\nT_AddBuyOpiTo(Code, Price, Vol)把多头仓位增加到某一数值。Code(字符串):合约代码,Price(小数):价格,Vol(整数):成交量 对合约代码为Code的字符串以Price价格下单达到多头vol手持仓\r\n\r\n注：\r\n该函数不支持回测。\r\n例：\r\nT_AddBuyOpiTo("m1009", Price("m1009")+5, 10); //买开使多头持仓达到10手\r\n\r\n注：只算本模型所持仓位，交易系统持仓不算。
body=T_AddBuyOpiTo( , , )

[T_AddSellOpiTo]
type=5
test=0
explanation=卖开达到指定目标量
description=根据当前成交的量采用卖开的手段达到把仓位增加到指定值的目的。\r\n用法：\r\nT_AddSellOpiTo(Code, Price, Vol)把空头仓位增加到某一数值。Code(字符串):合约代码,Price(小数):价格,Vol(整数):成交量 对合约代码为Code的字符串以Price价格下单达到多头vol手持仓\r\n\r\n注：\r\n该函数不支持回测。\r\n例：\r\nT_AddSellOpiTo("m1009", Price("m1009")-5, 10); //卖开使空头持仓达到10手\r\n\r\n注：只算本模型所持仓位，交易系统持仓不算。
body=T_AddSellOpiTo( , , )

[T_ReduceBuyOpiTo]
type=5
test=0
explanation=卖平达到指定剩余的买仓
description=根据当前成交的量采用卖平的手段达到把仓位减少到某一数值的目的。\r\n用法：\r\nT_ReduceBuyOpiTo(Code, Price, Vol)把多头仓位减少到某一数值。Code(字符串):合约代码,Price(小数):价格,Vol(整数):成交量 对合约代码为Code的字符串以Price价格下单达到多头vol手持仓\r\n\r\n注：\r\n该函数不支持回测。\r\n例：\r\nT_ReduceBuyOpiTo("m1009", Price("m1009")-5, 10); //卖平使多头持仓减少到10手\r\n\r\n注：\r\n1、只算本模型所持仓位，交易系统持仓不算。\r\n2、如果合约代码为上期所合约或者上期能源合约，该函数只能平老仓，不平今仓。
body=T_ReduceBuyOpiTo( , , )

[T_ReduceSellOpiTo]
type=5
test=0
explanation=买平达到指定剩余的卖仓
description=根据当前成交的量采用买平的手段达到把仓位减少到某一数值的目的。\r\n用法：\r\nT_ReduceSellOpiTo(Code, Price, Vol)把空头仓位减少到某一数值。Code(字符串):合约代码,Price(小数):价格,Vol(整数):成交量 对合约代码为Code的字符串以Price价格下单达到空头vol手持仓\r\n\r\n注：\r\n该函数不支持回测。\r\n例：\r\nT_ReduceSellOpiTo("m1009", Price("m1009")-5, 10); //买平使空头持仓减少到10手\r\n\r\n注：\r\n1、只算本模型所持仓位，交易系统持仓不算。\r\n2、如果合约代码为上期所合约或者上期能源合约，该函数只能平老仓，不平今仓。
body=T_ReduceSellOpiTo( , , )

[T_StgBuyVol]
type=5
test=1
explanation=算法交易模型产生多头持仓数
description=当前算法交易模型产生的某品种的多头持仓。\r\n用法：\r\nT_StgBuyVol(Code)返回当前算法交易模型产生的合约代码为Code的合约的多头持仓数。Code(字符串):合约代码\r\n\r\n注：\r\n1、盘口模型通过执行开多仓操作增加了N手多头持仓，T_StgBuyVol(Code)的返回值是N；盘口模型通过执行平多仓操作减少了N手多头持仓，T_StgBuyVol(Code)的返回值是-N\r\n\r\n例：\r\nMessageOut(T_StgBuyVol("IF1909"));//当前算法交易模型产生的某品种多头持仓数
body=T_StgBuyVol( )

[T_StgSellVol]
type=5
test=1
explanation=算法交易模型产生空头持仓数
description=当前算法交易模型产生产生的某品种的空头持仓。\r\n用法：\r\nT_StgSellVol(Code)返回当前算法交易模型产生的合约代码为Code的合约的空头持仓数。Code(字符串):合约代码\r\n\r\n注：\r\n1、盘口模型通过执行开空仓操作增加了N手空头持仓，T_StgSellVol(Code)的返回值是N；盘口模型通过执行平空仓操作减少了N手空头持仓，T_StgSellVol(Code)的返回值是-N\r\n\r\n例：\r\nMessageOut(T_StgSellVol("IF1909"));//当前算法交易模型产生的某品种空头持仓数
body=T_StgSellVol( )

[T_OrderMatchVol]
type=5
test=1
explanation=某次委托的已成交数量
description=某次委托已经成交的数量。\r\n用法：\r\nT_OrderMatchVol(OrderID)根据委托唯一标识OrderID查询委托成交手数,返回成交手数。OrderID(字符串)\r\n例：\r\nVAR matchvol;\r\nmatchvol=T_OrderMatchVol(X); //matchvol为某次委托的已成交数量
body=T_OrderMatchVol( )

[MinPrice]
type=0
test=1
explanation=某合约最小变动价位
description=某合约最小变动价位。\r\n用法：\r\nMinPrice(Code)返回合约Code的最小变动价位，Code为某合约的合约代码\r\n例：\r\nVAR minprice;//定义一个变量minprice\r\nminprice=MinPrice("m1009"); //minprice的值为合约m1009的最小变动价位
body=MinPrice()

[T_IsNoOrder]
type=5
test=1
explanation=该算法交易模型无挂单
description=该算法交易模型无挂单(发出的所有委托都已经成交，或被撤单)。\r\n用法：\r\nT_IsNoOrder()如果没有挂单返回1，否则返回0\r\n例：\r\nIF(T_IsNoOrder()) //如果没有挂单
body=T_IsNoOrder()

[T_GetFallLimit]
type=2
test=0
explanation=获取跌停价
description=返回某合约的跌停价\r\n用法：T_GetFallLimit(Code);返回合约Code的跌停价\r\n例：\r\nVAR FallLimit;\r\nFallLimit=T_GetFallLimit("m1105"); 获取成功返回合约1105的跌停价，失败返回0
body=T_GetFallLimit()

[T_GetRiseLimit]
type=2
test=0
explanation=获取涨停价
description=返回某合约的涨停价\r\n用法：T_GetRiseLimit(Code);返回合约Code的涨停价\r\n例：\r\nVAR RiseLimit;\r\nRiseLimit=T_GetRiseLimit("m1105"); 获取成功返回合约1105的涨停价，失败返回0
body=T_GetRiseLimit()

[MAX]
type=3
test=1
explanation=取较大值
description=MAX(A,B)：取最大值。取A，B中较大者。\r\n注：\r\n若A=B，返回值为A或者B的值。\r\n例：\r\nMessageOut(MAX(F_High(1),F_High(2)));//输出模组中前一根K线和前两根K线的最高价里面较大的值。
body=MAX(,)

[MIN]
type=3
test=1
explanation=取较小值
description=MIN(A,B)：取最小值。取A，B中较小者。\r\n注：\r\n若A=B，返回值为A或者B的值。\r\n例：\r\nMessageOut(MIN(F_High(1),F_High(2)));//输出模组中前一根K线和前两根K线的最高价里面较小的值。
body=MIN(,)

[F_CurrentPos]
type=4
test=0
modifytime=2014-08-05
explanation=取当前K线位置
description=AA.F_CurrentPos() 取当前K线位置\r\n\r\n注：\r\n该函数前必须用AA.的形式来调用，其中AA为字符串变量或者模组名。该函数不能单独使用。\r\n\r\n例：\r\nMessageOut(AA.F_CurrentPos());//输出当前K线所在的位置
body=F_CurrentPos()

[F_CurrentSigPos]
type=4
test=0
modifytime=2014-08-05
explanation=取当前信号所在K线的位置
description=AA.F_CurrentSigPos 取当前信号所在K线的位置\r\n\r\n注：\r\n该函数前必须用AA.的形式来调用，其中AA为字符串变量或者模组名。该函数不能单独使用。\r\n\r\n例：\r\nVAR A;\r\nVOID MAIN()\r\n{\r\nAA.F_FreshSig();\r\nIF(AA.F_Sig()==BK)\r\n{\r\nA=AA.F_CurrentSigPos();\r\n}\r\n}
body=F_CurrentSigPos()

[F_IsTimeToKlineEnd]
type=1
test=0
modifytime=2014-08-05
explanation=判断当前时间是否距离K线走完小于等于N秒
description=AA.F_IsTimeToKlineEnd(N) 判断当前时间是否距离K线走完小于等于N秒；如果离当根K线走完时间小于等于N秒返回1 否则返回0\r\n\r\n注：\r\n该函数前必须用AA.的形式来调用，其中AA为字符串变量或者模组名。该函数不能单独使用。\r\n\r\n例：\r\nVOID MAIN()\r\n{\r\nAA.F_FreshSig();\r\nIF(AA.F_Sig()==BK&&AA.F_IsTimeToKlineEnd(5)==1)\r\n{\r\nT_Deal(AA.F_DealCode(),0,0,1,0);\r\n}\r\n}\r\n//如果信号为BK信号并且离K线走完小于等于5秒中，买开1手当前加载合约
body=F_IsTimeToKlineEnd()

[GLOBAL_VAR]
type=2
test=1
explanation=定义全局变量
description=GLOBAL_VAR 定义全局变量\r\n\r\n注：\r\n1、相当于原来注册、读取变量的写法\r\n2、可以自动识别 整型、浮点型、字符串类型\r\n\r\n例：\r\nGLOBAL_VAR A1;\r\nVOID MAIN()\r\n{     \r\n      IF(A1<5)\r\n      {\r\n       A1=A1+1; \r\n      MessageOut(A1);\r\n      }\r\n}\r\n与下面的写法意思相同\r\nVAR A1;\r\nVOID MAIN()\r\n{\r\n      A1=ReadGlobal("A1");\r\n      IF(A1<5)\r\n      {\r\n       A1=A1+1;\r\n      WriteGlobal("A1",A1);\r\n      MessageOut(A1);\r\n      }\r\n}
body=GLOBAL_VAR

[T_InitialEquity]
type=5
test=0
explanation=取期初权益
description=T_InitialEquity(type) 取期初权益\r\n\r\n注：\r\ntype的取值：\r\n0 内盘 \r\n1股票\r\n2外盘\r\n\r\n注：\r\n该函数不支持回测。\r\n\r\n例：\r\nMessageOut(T_InitialEquity(0));
body=T_InitialEquity()

[Year]
type=2
test=1
explanation=年份
description=Year(time) 取得当前时间的年份\r\n\r\n注：\r\ntime的取值：可以为本机时间CurrentTime()，也可以为交易所时间CurrentServerTime("CODE")\r\n\r\n例：\r\nVAR year;\r\nyear = Year(CurrentServerTime("m1909"));//定义一个变量year,year的值为当前豆粕1909合约最后一笔行情服务器时间的年份
body=Year()

[Month]
type=2
test=1
explanation=月份
description=Month(time) 取得当前时间的月份\r\n\r\n注：\r\ntime的取值：可以为本机时间CurrentTime()，也可以为交易所时间CurrentServerTime("CODE")\r\n\r\n例：\r\nVAR month;\r\nmonth = Month(CurrentServerTime("m1909"));//定义一个变量month,month的值为当前豆粕1909合约最后一笔行情服务器时间的月份
body=Month()

[Hour]
type=2
test=1
explanation=小时
description=Hour(time) 取得当前时间的小时\r\n\r\n注：\r\ntime的取值：可以为本机时间CurrentTime()，也可以为交易所时间CurrentServerTime("CODE")\r\n\r\n例：\r\nVAR hour;\r\nhour = Hour(CurrentServerTime("m1909"));//定义一个变量hour,hour的值为当前豆粕1909合约最后一笔行情服务器时间的小时
body=Hour()

[Minute]
type=2
test=1
explanation=分钟
description=Minute(time) 取得当前时间的分钟\r\n\r\n注：\r\ntime的取值：可以为本机时间CurrentTime()，也可以为交易所时间CurrentServerTime("CODE")\r\n\r\n例：\r\nVAR minute;\r\nminute = Minute(CurrentServerTime("m1909"));//定义一个变量minute,minute的值为当前豆粕1909合约最后一笔行情服务器时间的分钟
body=Minute()

[Second]
type=2
test=1
explanation=秒数
description=Second(time) 取得当前时间的秒数\r\n\r\n注：\r\ntime的取值：可以为本机时间CurrentTime()，也可以为交易所时间CurrentServerTime("CODE")\r\n\r\n例：\r\nVAR second;\r\nsecond = Second(CurrentServerTime("m1909"));//定义一个变量second,second的值为当前豆粕1909合约最后一笔行情服务器时间的秒数
body=Second()

[T_OrderMatchAvPrice]
type=5
test=1
explanation=成交均价
description=T_OrderMatchAvPrice(OrderID) 根据委托唯一标识OrderID获取成交均价\r\n\r\n注：\r\n1、OrderID可参考T_Deal()函数\r\n\r\n例：GLOBAL_VAR BKID,N;\r\nVOID MAIN()\r\n{\r\nVAR AvPrice; \r\n IF(N==0)\r\n{\r\n    BKID=T_Deal("IF1909",0,0,10,0);\r\n    N=1;\r\n}\r\nAvPrice = T_OrderMatchAvPrice(BKID);\r\nMessageOut(AvPrice);\r\n}\r\n
body=T_OrderMatchAvPrice()


[F_IsLastKline]
type=1
test=0
modifytime=2014-08-05
explanation=判断当前K线是否为休盘前最后一根K线
description=AA.F_IsLastKline(type) 判断当前K线是否为休盘前最后一根K线\r\n\r\n注：\r\n1、type 为0 判断是否是各个小节以及闭盘前最后一根K线\r\ntype 为非0 判断是否是当日K线结束闭盘前最后一根K线\r\n2、该函数前必须用AA.的形式来调用，其中AA为字符串变量或者模组名。该函数不能单独使用。\r\n\r\n例：\r\nGLOBAL_VAR BKID,N;\r\nVOID MAIN()\r\n{\r\nN=AA.F_IsLastKline(0);\r\nMessageOut(N);\r\n}
body=F_IsLastKline()

[Week]
type=2
test=1
explanation=星期数
description=Week(Time);当前时间对应星期数\r\n用法：\r\n1、参数Time为当前秒数，即可以为CurrentTime()，CurrentServerTime("CODE")，LastOrderTime()等\r\n2、Week(Time);返回值为：\r\n0，星期日\r\n1，星期一\r\n2，星期二\r\n3，星期三\r\n4，星期四\r\n5，星期五\r\n6，星期六\r\n\r\n例：\r\nVAR Week;\r\nVOID MAIN()\r\n{\r\n    Week=Week(CurrentServerTime("CODE"));\r\n    MessageOut(Week);\r\n}
body=Week( )

[#Get]
type=2
test=0
explanation=指定模组名称的模型中指定变量在某根K线上的值
description=#Get("module name","variable name",n), 指定模组名称的模型中指定变量在某根K线上的值\r\n用法：\r\n#Get("股指连续加载","MA5",0), 返回正在运行的“股指连续加载”这个模组的模型中变量MA5在当根K线上的返回值\r\n\r\n注：\r\n1、module name模组名，variable name变量名，类型为字符串\r\n2、n表示取值为倒数第n+1K线上的值，如果n为0，表示为当根K线；如果n为1表示前一根K线\r\n3、指定的模组必须正在运行\r\n\r\n例：\r\n运行的模组“股指连续加载”，加载的模型中为：\r\nMA5:=MA(C,5);\r\n\r\n组件编写为：\r\nVAR Ma5;\r\nVOID MAIN()\r\n{\r\n Ma5=#Get("股指连续加载","MA5",0);//返回正在运行的“股指连续加载”这个模组的模型中变量MA5在当根K线上的返回值\r\n}
body=#Get(,,)

[Delta]
type=6
test=0
createtime = 2014-03-25
modifytime=2014-03-25
explanation=取得某期权合约的Delta值
description=取得某期权合约的Delta值。\r\n用法：\r\nDelta(Code)返回合约Code的Delta值，Code为某期权合约的合约代码。\r\n\r\n注：\r\n1、Delta表示某期权合约的价位风险，该指标衡量的是标的资产价格变动时，期权价格的变化幅度。\r\n2、Delta=权利金的变化/相应标的物价格的变化。\r\n\r\n例：\r\nVAR qqDelta;//定义一个变量qqDelta\r\nqqDelta=Delta("IO1404-P-2450"); //qqDelta的值为合约号为IO1404-P-2450的期权合约的Delta值。
body=Delta()

[Gamma]
type=6
test=0
createtime = 2014-03-25
modifytime=2014-03-25
explanation=取得某期权合约的Gamma值
description=取得某期权合约的Gamma值。\r\n用法：\r\nGamma(Code)返回合约Code的Gamma值，Code为某期权合约的合约代码。\r\n\r\n注：\r\n1、Gamma衡量期权标的物价格的变化所引起的Delta值的变化。也就是期权的斜率。\r\n2、Gamma=Delta的变化量/相应标的物价格的变化。\r\n\r\n例：\r\nVAR qqGamma;//定义一个变量qqGamma\r\nqqGamma=Gamma("IO1404-P-2450"); //qqGamma的值为合约号为IO1404-P-2450的期权合约的Gamma值。
body=Gamma()

[Vega]
type=6
time=0
createtime = 2014-03-25
modifytime=2014-03-25
explanation=取得某期权合约的Vega值
description=取得某期权合约的Vega值。\r\n用法：\r\nVega(Code)返回合约Code的Vega值，Code为某期权合约的合约代码。\r\n\r\n注：\r\n1、Vega计量期权的波幅风险。用来衡量当标的物价格的波幅每升跌1%对权利金的影响。\r\n2、Vega=权利金的变动/波动率的变动。\r\n\r\n例：\r\nVAR qqVega;//定义一个变量qqVega\r\nqqVega=Vega("IO1404-P-2450"); //qqVega的值为合约号为IO1404-P-2450的期权合约的Vega值。
body=Vega()

[Theta]
type=6
test=0
createtime = 2014-03-25
modifytime=2014-03-25
explanation=取得某期权合约的Theta值
description=取得某期权合约的Theta值。\r\n用法：\r\nTheta(Code)返回合约Code的Theta值，Code为某期权合约的合约代码。\r\n\r\n注：\r\n1、Theta计量时间经过的风险。用来衡量期权的理论价值因为时间经过而下降的速度。\r\n2、Theta=权利金的变动/距到期日时间的变动。\r\n\r\n例：\r\nVAR qqTheta;//定义一个变量qqTheta\r\nqqTheta=Theta("IO1404-P-2450"); //qqTheta的值为合约号为IO1404-P-2450的期权合约的Theta值。
body=Theta()

[Rho]
type=6
test=0
createtime = 2014-03-25
modifytime=2014-03-25
explanation=取得某期权合约的Rho值
description=取得某期权合约的Rho值。\r\n用法：\r\nRho(Code)返回合约Code的Rho值，Code为某期权合约的合约代码。\r\n\r\n注：\r\n1、Rho计量利率变动的风险。用来衡量期权的理论价值对于利率变动的敏感性，即市场利率每升跌1%对权利金的影响。\r\n2、实值期权的Rho>平值期权的Rho>虚值期权的Rho。\r\n3、Rho=权利金的变动/利率的变动。\r\n\r\n例：\r\nVAR qqRho;//定义一个变量qqRho\r\nqqRho=Rho("IO1404-P-2450"); //qqRho的值为合约号为IO1404-P-2450的期权合约的Rho值。
body=Rho()

[TheoreticalValue]
type=6
test=0
createtime = 2014-03-25
modifytime=2014-03-25
explanation=取得某期权合约的理论价格
description=取得某期权合约的理论价格。\r\n用法：\r\nTheoreticalValue(Code)返回合约Code的理论价格，Code为某期权合约的合约代码。\r\n\r\n例：\r\nVAR qqTheoreticalValue;//定义一个变量qqTheoreticalValue\r\nqqTheoreticalValue=TheoreticalValue("IO1404-P-2450"); //qqTheoreticalValue的值为合约号为IO1404-P-2450的期权合约的理论价格。
body=TheoreticalValue()

[TimeValue]
type=6
test=0
createtime = 2014-03-25
modifytime=2014-03-25
explanation=取得某期权合约的时间价值
description=取得某期权合约的时间价值。\r\n用法：\r\nTimeValue(Code)返回合约Code的时间价值，Code为某期权合约的合约代码。\r\n\r\n注：\r\n1、期权的时间价值，也称外在价值，是指期权合约的购买者为购买期权而支付的权利金超过期权内在价值的那部分价值。\r\n2、TimeValue=Max(0,期权最新价-期权内在价值)。\r\n\r\n例：\r\nVAR qqTimeValue;//定义一个变量qqTimeValue\r\nqqTimeValue=TimeValue("IO1404-P-2450"); //qqTimeValue的值为合约号为IO1404-P-2450的期权合约的时间价值。
body=TimeValue()

[IntrinsicValue]
type=6
test=0
createtime = 2014-03-25
modifytime=2014-03-25
explanation=取得某期权合约的内在价值
description=取得某期权合约的内在价值。\r\n用法：\r\nIntrinsicValue(Code)返回合约Code的内在价值，Code为某期权合约的合约代码。\r\n\r\n注：\r\n1、期权价格=期权的内在价值+期权的时间价值。内在价值，是指多方行使期权时可以获得的收益的现值，即期权立即履约（即假定是一种美式期权）时的价值。\r\n2、\r\n买入期权的内在价值=Max(0,当前标的物价格-期权执行价)\r\n卖出期权的内在价值=Max(0,期权执行价-当前标的物价格)\r\n\r\n例：\r\nVAR qqIntrinsicValue;//定义一个变量qqIntrinsicValue\r\nqqIntrinsicValue=IntrinsicValue("IO1404-P-2450"); //qqIntrinsicValue的值为合约号为IO1404-P-2450的期权合约的内在价值。
body=IntrinsicValue()

[ImpliedVolatility]
type=6
test=0
createtime = 2014-03-25
modifytime=2014-03-25
explanation=取得某期权合约的隐含波动率
description=取得某期权合约的隐含波动率。\r\n用法：\r\nImpliedVolatility(Code)返回合约Code的隐含波动率，Code为某期权合约的合约代码。\r\n\r\n注：\r\n期权的隐含波动率，代表整个市场对未来价格波动的预期。\r\n\r\n例：\r\nVAR qqImpliedVolatility;//定义一个变量qqImpliedVolatility\r\nqqImpliedVolatility=ImpliedVolatility("IO1404-P-2450"); //qqImpliedVolatility的值为合约号为IO1404-P-2450的期权合约的隐含波动率。
body=ImpliedVolatility()

[ExpirationDate]
type=6
test=0
createtime = 2014-03-25
modifytime=2014-03-25
explanation=取得某期权合约的行权日
description=取得某期权合约的行权日。\r\n用法：\r\nExpirationDate(Code)返回合约Code的行权日秒数，Code为某期权合约的合约代码。\r\n\r\n注：\r\n该函数返回1970年1月1日至行权日的总秒数。\r\n\r\n例：\r\nVAR qqExpirationDate;//定义一个变量qqExpirationDate\r\nqqExpirationDate=ExpirationDate("IO1404-P-2450"); //qqExpirationDate的值为合约号为IO1404-P-2450的期权合约的行权日秒数\r\nMessageOut(DateToStr(qqExpirationDate)); //输出行权日的日期。
body=ExpirationDate()

[CallPut]
type=6
test=0
createtime = 2014-03-25
modifytime=2014-03-25
explanation=取得某期权合约的涨/跌
description=取得某期权合约的涨/跌。\r\n用法：\r\nCallPut(Code)返回合约Code的涨/跌，Code为某期权合约的合约代码。\r\n\r\n注：\r\n该函数返回0，表示put，即期权合约是看跌期权；该函数返回1，表示call，即期权合约是看涨期权。\r\n\r\n例：\r\nVAR qqCallPut;//定义一个变量qqCallPut\r\nqqCallPut=CallPut("IO1404-P-2450"); //qqCallPut的值为合约号为IO1404-P-2450的期权合约的涨/跌。\r\nMessageOut(qqCallPut); //输出的值为0，即该合约为看跌期权。
body=CallPut()

[StrikePrice]
type=6
test=0
createtime = 2014-03-25
modifytime=2014-03-25
explanation=取得某期权合约的行权价
description=取得某期权合约的行权价。\r\n用法：\r\nStrikePrice(Code)返回合约Code的行权价，Code为某期权合约的合约代码。\r\n\r\n例：\r\nVAR qqStrikePrice;//定义一个变量qqStrikePrice\r\nqqStrikePrice=StrikePrice("IO1404-P-2450"); //qqStrikePrice的值为合约号为IO1404-P-2450的期权合约的行权价。
body=StrikePrice()

[Leverage]
type=6
test=0
createtime = 2014-03-25
modifytime=2014-03-25
explanation=取得某期权合约的杠杆比率
description=取得某期权合约的杠杆比率。\r\n用法：\r\nLeverage(Code)返回合约Code的杠杆比率，Code为某期权合约的合约代码。\r\n\r\n注：\r\n1、杠杆比率是期权仓位所代表的实际价值与建立仓位所付出的现金额的比率。\r\n2、杠杆比率越高，市场价格每单位的变动可带来的盈利或亏损就越大，意味着投资风险较高。\r\n3、杠杆比率 = 当前标的物价格/期权最新价。\r\n\r\n例：\r\nVAR qqLeverage;//定义一个变量qqLeverage\r\nqqLeverage=Leverage("IO1404-P-2450"); //qqLeverage的值为合约号为IO1404-P-2450的期权合约的杠杆比率。
body=Leverage()

[ActualLeverage]
type=6
test=0
createtime = 2014-03-25
modifytime=2014-03-25
explanation=取得某期权合约的真实杠杆率
description=取得某期权合约的真实杠杆率。\r\n用法：\r\nActualLeverage(Code)返回合约Code的真实杠杆率，Code为某期权合约的合约代码。\r\n\r\n注：\r\n真实杠杆率=Delta*杠杆比率\r\n\r\n例：\r\nVAR qqActualLeverage;//定义一个变量qqActualLeverage\r\nqqActualLeverage=ActualLeverage("IO1404-P-2450"); //qqActualLeverage的值为合约号为IO1404-P-2450的期权合约的真实杠杆率。
body=ActualLeverage()

[PremiumRate]
type=6
test=0
createtime = 2014-03-25
modifytime=2014-03-25
explanation=取得某期权合约的溢价率
description=取得某期权合约的溢价率。\r\n用法：\r\nPremiumRate(Code)返回合约Code的溢价率，Code为某期权合约的合约代码。\r\n\r\n注：\r\n1、溢价指所支付的实际金额超过面值的部分。\r\n2、\r\n买入期权的溢价率 = ((期权执行价+期权最新价)-当前标的物价格)/当前标的物价格*100.0\r\n卖出期权的溢价率 = (当前标的物价格-(期权执行价-期权最新价))/当前标的物价格*100.0\r\n\r\n例：\r\nVAR qqPremiumRate;//定义一个变量qqPremiumRate\r\nqqPremiumRate=PremiumRate("IO1404-P-2450"); //qqPremiumRate的值为合约号为IO1404-P-2450的期权合约的溢价率。
body=PremiumRate()

[F_LastOffSetProfit]
type=4
test=0
createtime = 2014-03-25
modifytime=2014-08-05
explanation=取得模组最近一次的平仓盈亏
description=取得模组最近一次的平仓盈亏。\r\n用法：\r\nAA.F_LastOffSetProfit()返回模组最近一次的平仓盈亏。\r\n\r\n注：\r\n1、该函数返回值与监控运行日志中模组最近一次平仓盈亏取值一致。\r\n2、平仓盈亏=（平仓成交价-开仓成交价）*手数*交易单位。\r\n（1）其中开仓价格是按照持仓明细，遵循先开先平的原则进行计算。\r\n（2）初始化的持仓，如果为自动初始化，开仓成交价按照自动初始化对话框中的持仓价格计算；如果为手动初始化，开仓成交价按照初始化框中显示的信号价计算。\r\n3、该函数前必须用AA.的形式来调用，其中AA为字符串变量或者模组名。该函数不能单独使用。\r\n4、只有在对应的模组源码中写入SETMODRUNTYPE(0)或者不写入SETMODRUNTYPE函数时，即按照模组中设置的信号执行方式出信号并下单时，该函数才可以取到值。\r\n\r\n例：\r\nVAR lastoffsetprofit;//定义一个变量lastoffsetprofit\r\nlastoffsetprofit=AA.F_LastOffSetProfit(); //lastoffsetprofit的值为当前对应模组AA的最近一次平仓盈亏。
body=F_LastOffSetProfit()

[F_OffSetProfit]
type=4
test=0
createtime = 2014-03-25
modifytime=2014-08-05
explanation=取得模组加载开始到现在的累计平仓盈亏
description=取得模组加载开始到现在的累计平仓盈亏。\r\n用法：\r\nAA.F_OffSetProfit()返回模组加载开始到现在的累计平仓盈亏。\r\n\r\n注：\r\n1、该函数与模组中显示的平仓盈亏的累计值一致。\r\n2、平仓盈亏=（平仓成交价-开仓成交价）*手数*交易单位。\r\n（1）其中开仓价格是按照持仓明细，遵循先开先平的原则进行计算。\r\n（2）初始化的持仓，如果为自动初始化，开仓成交价按照自动初始化对话框中的持仓价格计算；如果为手动初始化，开仓成交价按照初始化框中显示的信号价计算。\r\n3、该函数前必须用AA.的形式来调用，其中AA为字符串变量或者模组名。该函数不能单独使用。\r\n4、只有在对应的模组源码中写入SETMODRUNTYPE(0)或者不写入SETMODRUNTYPE函数时，即按照模组中设置的信号执行方式出信号并下单时，该函数才可以取到值。\r\n\r\n例：\r\nVAR offsetprofit;//定义一个变量offsetprofit\r\noffsetprofit=AA.F_OffSetProfit();//offsetprofit的值为模组加载开始到现在的累计平仓盈亏。
body=F_OffSetProfit()

[F_SigGroup]
type=4
test=0
createtime = 2014-04-14
modifytime=2014-08-05
explanation=读取当前信号对应的组
description=读取当前信号对应的组 \r\n用法：\r\nAA.F_SigGroup()，读当前信号对应的组。\r\n注：\r\n1、该函数必须与AA.F_FreshSig()刷新信号函数同时使用。\r\n2、该函数前必须用AA.的形式来调用，其中AA为字符串变量或者模组名。该函数不能单独使用。\r\n\r\n例：\r\nIF(AA.F_FreshSig()==1)\r\n{\r\n       IF(AA.F_SigGroup()=="A")\r\n}//如果信号是A组的信号。
body=F_SigGroup()

[Price]
type=0
test=1
createtime=2014-06-12
modifytime=2014-07-17
explanation=取得某一合约的行情报价数据
description=根据文华码取报价列表窗口某一个合约的行情报价数据。\r\n\r\n用法：\r\nPrice("CODE", "DATA");取合约名为CODE的合约的DATA数据。CODE可以为文华码。\r\nDATA可以取以下数据：\r\n\r\nOpen 开盘价\r\nHigh 最高价\r\nLow 最低价\r\nNew 最新价\r\nDelta1 涨跌\r\nBid 买价\r\nBidVol 买量\r\nAsk 卖价\r\nAskVol 卖量\r\nDeltaVol 现手\r\nDeltaOpI 增仓\r\nVolume 成交量\r\nOpIorSize 持仓量\r\nRatio 日增仓\r\nUpDown 涨幅\r\nAvPrice均价\r\nSettle 结算价\r\nYSettle 昨结算\r\nYClose 昨收\r\nCapital 沉淀资金\r\nDirection 资金流向\r\nSpeculation 投机度\r\nAskActivityVol 内盘\r\n BidActivityVol 外盘\r\n\r\n期权：\r\nPremiumRate 溢价率\r\nActualLeverage 真实杠杆率\r\nLeverage 杠杆比率\r\nStrikePrice 行权价\r\nCallPut 涨/跌\r\nHistoricalVolatility  历史波动率\r\nStdderiation  隐含波动率 \r\nInternalValue 内在价值\r\nTimeValue 时间价值\r\nTheoryPrice 理论价格\r\nRho Rho值\r\nTheta  Theta值\r\nVega Vega值\r\nGamma  Gamma值\r\n\r\n注：\r\n1、在清盘时间该函数收不到数据，返回值为0。\r\n2、该函数只支持部分数据回测。支持回测的数据有Open 开盘价；High 最高价；Low 最低价；New 最新价；Volume 成交量；OpIorSize 持仓量；Bid 买价；BidVol 买量；Ask 卖价；AskVol 卖量\r\n\r\n例：\r\nVAR price1;//定义一个变量price1\r\nVOID MAIN()\r\n{\r\nprice1=Price("m1409", "Open");//取得豆粕1409的开盘价\r\nMessageOut(price1);\r\n}
body=Price()

[Price1]
type=0
test=1
createtime=2014-06-12
modifytime=2014-07-17
explanation=取得某一合约的行情报价数据
description=根据文华码取报价列表窗口某一个合约的行情报价数据。\r\n\r\n用法：\r\nPrice1("CODE", "DATA");取合约名为CODE的合约的DATA数据。\r\nDATA可以取以下数据：\r\nName 合约名\r\nUnit 报价单位\r\nNumOfUnit 交易单位\r\nLastDate 摘牌日\r\nMEName 交易所\r\n\r\n注：在清盘时间该函数收不到数据，返回值为0。\r\n\r\n例：\r\nVAR price1;//定义一个变量price1\r\nVOID MAIN()\r\n{\r\nprice1=Price1("m1409", "Unit");//取得豆粕1409的交易单位\r\nMessageOut(price1);\r\n}
body=Price1()

[tickdata1]
type=0
test=1
createtime=2014-06-11
modifytime=2015-08-05
explanation=定义Tick数据区
description=定义Tick数据区。\r\n\r\n用法：\r\nDef_TickData(Code,Type,Num);Code为合约名，Type为0时，Num表示多少秒（最大60秒）；Type为1时，Num表示多少笔（最大200笔）。\r\n\r\n注：使用该函数前，需要用VAR_TICKDATA定义变量。\r\n\r\n例：\r\nVAR_TICKDATA data;\r\nVOID MAIN()\r\n{\r\ndata=Def_TickData("m1409",0,5); //data中装有5秒钟m1409的tick数据\r\nIF(data.State == 1)\r\n{\r\ndata.Num; // 表示data数组有多大\r\ndata[0].Ask1; // 表示第一笔tick数据的卖一价。\r\ndata[data.Num-1].Ask1;// 表示最新一笔tick的卖一价。\r\n}\r\n}\r\nAsk1可以替换为：\r\nAsk2 卖2价\r\nAsk3 卖3价\r\nAsk4 卖4价\r\nAsk5 卖5价\r\nBid1 买1价\r\n Bid2 买2价\r\nBid3 买3价\r\nBid4 买4价\r\nBid5 买5价\r\nAskvol1 卖1量\r\nAskvol2 卖2量\r\nAskvol3 卖3量\r\nAskvol4 卖4量\r\nAskvol5 卖5量\r\nBidvol1 买1量\r\nBidvol2 买2量\r\nBidvol3 买3量\r\nBidvol4 买4量\r\nBidvol5 买5量\r\nNum data数组大小\r\nTickOpi 持仓量\r\nTickPrice 当笔tick数据的价格\r\nTickVolum 从开盘到当笔tick数据的成交量累计值\r\nActivity 返回0为主动买 返回1为主动卖 返回2为既不是主动买也不是主动卖
body=Def_TickData()

[tickdata2]
type=0
test=1
createtime=2014-06-11
modifytime=2014-08-07
explanation=定义数据区变量
description=定义数据区变量。\r\n\r\n用法：\r\nVAR_TICKDATA data;//定义数据区变量\r\nDef_TickData(Code,Type,Num);//定义TICK数据区。Code为合约名，Type为0时，Num表示多少秒（最大60秒）；Type为1时，Num表示多少笔（最大200笔）。\r\n\r\n注：类型变量0为第一笔数据，Num-1为最后一笔\r\n\r\n例：\r\nVAR_TICKDATA data;\r\nVOID MAIN()\r\n{\r\ndata=Def_TickData("m1409",0,5); //data中装有5秒钟m1409的tick数据\r\nIF(data.State == 1)\r\n{\r\ndata.Num; // 表示data数组有多大\r\ndata[0].Ask1; // 表示第一笔tick数据的卖一价。\r\ndata[data.Num-1].Ask1;// 表示最新一笔tick的卖一价。\r\n}\r\n}\r\nAsk1可以替换为：\r\nAsk2 卖2价\r\nAsk3 卖3价\r\nAsk4 卖4价\r\nAsk5 卖5价\r\nBid1 买1价\rnBid2 买2价\r\nBid3 买3价\r\nBid4 买4价\r\nBid5 买5价\r\nAskvol1 卖1量\r\nAskvol2 卖2量\r\nAskvol3 卖3量\r\nAskvol4 卖4量\r\nAskvol5 卖5量\r\nBidvol1 买1量\r\nBidvol2 买2量\r\nBidvol3 买3量\r\nBidvol4 买4量\r\nBidvol5 买5量\r\nTickPrice 当笔tick数据的价格\r\nTickVolum 从开盘到当笔tick数据的成交量累计值\r\nActivity 当笔Tick是否是主动买
body=VAR_TICKDATA

[AL_BuyPosition]
type=7
test=1
createtime=2014-06-18
modifytime=2014-08-05
explanation=取算法交易组件某合约多头持仓
description=取算法交易组件某合约多头持仓。\r\n\r\n用法：\r\nAL_BuyPosition("CODE");取算法交易组件中CODE合约的多头持仓，CODE为合约名。\r\n\r\n例：\r\nVAR fmlBuyPosition; \r\nfmlBuyPosition=AL_BuyPosition("m1409"); //定义一个变量fmlBuyPosition，fmlBuyPosition为组件中豆粕1409的多头持仓。
body=AL_BuyPosition()

[AL_SellPosition]
type=7
test=1
createtime=2014-06-18
modifytime=2014-08-05
explanation=取算法交易组件某合约空头持仓
description=取算法交易组件某合约空头持仓。\r\n\r\n用法：\r\nAL_SellPosition("CODE");取算法交易组件中CODE合约的空头持仓，CODE为合约名。\r\n\r\n例：\r\nVAR fmlSellPosition; \r\nfmlSellPosition=AL_SellPosition("m1409"); //定义一个变量fmlSellPosition，fmlSellPosition为组件中豆粕1409的空头持仓。
body=AL_SellPosition()

[AL_BuyRemainPosition]
type=7
test=1
createtime=2014-06-18
modifytime=2014-08-05
explanation=取算法交易组件某合约多头可用持仓
description=取算法交易组件某合约多头可用持仓。\r\n\r\n用法：\r\nAL_BuyRemainPosition("CODE");取算法交易组件中CODE合约的多头可用持仓，CODE为合约名。\r\n\r\n例：\r\nVAR fmlBuyRemainPosition; \r\nfmlBuyRemainPosition=AL_BuyRemainPosition("m1409"); //定义一个变量fmlBuyRemainPosition，fmlBuyRemainPosition为组件中豆粕1409的多头可用持仓。\r\n\r\n说明：可用持仓为刨除当前已挂单的多头持仓数量。
body=AL_BuyRemainPosition()

[AL_SellRemainPosition]
type=7
test=1
createtime=2014-06-18
modifytime=2014-08-05
explanation=取算法交易组件某合约空头可用持仓
description=取算法交易组件某合约空头可用持仓。\r\n\r\n用法：\r\nAL_SellRemainPosition("CODE");取算法交易组件中CODE合约的空头可用持仓，CODE为合约名。\r\n\r\n例：\r\nVAR fmlSellRemainPosition; \r\nfmlSellRemainPosition=AL_SellRemainPosition("m1409"); //定义一个变量fmlSellRemainPosition，fmlSellRemainPosition为组件中豆粕1409的空头可用持仓。\r\n\r\n说明：可用持仓为刨除当前已挂单的空头持仓数量。
body=AL_SellRemainPosition()

[AL_BuyAvgPrice]
type=7
test=1
createtime=2014-06-18
modifytime=2014-08-05
explanation=取算法交易组件某合约多头持仓成本价
description=取算法交易组件某合约多头持仓成本价。\r\n\r\n用法：\r\nAL_BuyAvgPrice("CODE");取算法交易组件中CODE合约的多头持仓成本价，CODE为合约名。\r\n\r\n例：\r\nVAR price; \r\nprice=AL_BuyAvgPrice("m1409"); //定义一个变量price，price为组件中豆粕1409的多头持仓成本价。
body=AL_BuyAvgPrice()

[AL_SellAvgPrice]
type=7
test=1
createtime=2014-06-18
modifytime=2014-08-05
explanation=取算法交易组件某合约空头持仓成本价
description=取算法交易组件某合约空头持仓成本价。\r\n\r\n用法：\r\nAL_SellAvgPrice("CODE");取算法交易组件中CODE合约的空头持仓成本价，CODE为合约名。\r\n\r\n例：\r\nVAR price; \r\nprice=AL_SellAvgPrice("m1409"); //定义一个变量price，price为组件中豆粕1409的空头持仓成本价。
body=AL_SellAvgPrice()

[AL_BuyProfitLoss]
type=7
test=1
createtime=2014-06-18
modifytime=2014-08-05
explanation=取算法交易组件某合约多头盈亏
description=取算法交易组件某合约多头盈亏。\r\n\r\n用法：\r\nAL_BuyProfitLoss("CODE");取算法交易组件中CODE合约的多头盈亏，CODE为合约名。\r\n\r\n例：\r\nVAR BuyEarn;\r\nBuyEarn=AL_BuyProfitLoss("m1409");// 定义一个变量BuyEarn,BuyEarn的值为组件中豆粕1409的多头盈亏。
body=AL_BuyProfitLoss()

[AL_SellProfitLoss]
type=7
test=1
createtime=2014-06-18
modifytime=2014-08-05
explanation=取算法交易组件某合约空头盈亏
description=取算法交易组件某合约空头盈亏。\r\n\r\n用法：\r\nAL_SellProfitLoss("CODE");取算法交易组件中CODE合约的空头盈亏，CODE为合约名。\r\n\r\n例：\r\nVAR SellEarn;\r\nSellEarn=AL_SellProfitLoss();// 定义一个变量SellEarn,SellEarn的值为组件中豆粕1409的空头盈亏。
body=AL_SellProfitLoss()

[AL_OffSetProfit]
type=7
test=1
createtime=2014-06-18
modifytime=2014-08-05
explanation=取算法交易组件平仓盈亏
description=取算法交易组件平仓盈亏。\r\n\r\n用法：\r\nAL_OffSetProfit();取算法交易组件中的平仓盈亏。\r\n\r\n注：\r\n1、该函数返回组件加载开始到现在的累计平仓盈亏\r\n2、平仓盈亏=（平仓成交价-开仓成交价）*手数*交易单位。\r\n其中开仓价格是按照持仓明细，遵循先开先平的原则进行计算。\r\n\r\n例：\r\nVAR offsetprofit;\r\noffsetprofit=AL_OffSetProfit();// 定义一个变量offsetprofit,offsetprofit的值为组件中的平仓盈亏。
body=AL_OffSetProfit()

[AL_LastOffSetProfit]
type=7
test=1
createtime=2014-06-18
modifytime=2014-08-05
explanation=取算法交易组件最近一次的平仓盈亏
description=取算法交易组件最近一次的平仓盈亏。\r\n\r\n用法：\r\nAL_LastOffSetProfit();取算法交易组件中最近一次的平仓盈亏。\r\n\r\n注：\r\n1、该函数返回最近一次的平仓盈亏。\r\n2、平仓盈亏=（平仓成交价-开仓成交价）*手数*交易单位。\r\n其中开仓价格是按照持仓明细，遵循先开先平的原则进行计算。\r\n\r\n例：\r\nVAR offsetprofit;\r\noffsetprofit=AL_LastOffSetProfit();// 定义一个变量offsetprofit,offsetprofit的值为该盘口模型最近一次的平仓盈亏。
body=AL_LastOffSetProfit()


[data.State]
type=0
test=1
createtime=2014-06-11
modifytime=2014-08-07
explanation=判断Tick数据区是否有效
description=判断Tick数据区是否有效。\r\n\r\n用法：\r\ndata.State返回1时，表示当前数据区已经满足了Def_TickData设置的TICK容量，当前数据区是有效的；如果不为1，则表示未达到设置的TICK容量，数据区无效。\r\n\r\n注：使用该函数前，需要用VAR_TICKDATA定义数据区，用Def_TickData定义数据区变量。\r\n\r\n例：\r\nVAR_TICKDATA data;\r\nVOID MAIN()\r\n{\r\ndata=Def_TickData("m1409",0,5); //data中装有5秒钟m1409的tick数据\r\nIF(data.State == 1)\r\n{\r\ndata.Num; // 表示data数组有多大\r\ndata[0].Ask1; // 表示第一笔tick数据的卖一价。\r\ndata[data.Num-1].Ask1;// 表示最新一笔tick的卖一价。\r\n}\r\n}
body=data.State

[F_InitCode]
type=4
test=0
createtime =2014-11-24
explanation=返回模组初始化交易合约的交易编码
description=读返回模组初始化交易合约的交易编码 \r\n用法：\r\nAA.F_InitCode()，读当前模组初始化交易合约的交易编码。\r\n注：该函数前必须用AA.的形式来调用，其中AA为字符串变量或者模组名。该函数不能单独使用。\r\n\r\n例：\r\nVAR Initcode;\r\nInitcode=AA.F_InitCode();  //变量Initcode的内容为模组AA初始化交易合约的交易编码
body=F_InitCode()

[Unit]
type=0
test=1
createtime =2015-03-23
explanation=取合约的交易单位
description=取合约的交易单位 \r\n用法：\r\nUnit(Code)返回合约Code的交易单位，Code为某合约的合约代码\r\n例：\r\nVAR nDanWei;//定义一个变量nDanWei\r\nnDanWei=Unit("m1509"); //Unit的值为合约m1509的交易单位
body=Unit()

[T_CloseAllOpi]
type=5
test=0
explanation=发出清仓委托
description=发出清仓委托。\r\n用法：\r\nT_CloseAllOpi(m,n),发出清仓委托。\r\nm:市场类型 0期货 1股票 2外盘\r\nn:委托价格方式 0排队价 1对价 2自动连续追价 3超价 4市价 5最新价\r\n\r\n注：\r\n该函数不支持回测。\r\n例：\r\nVAR orderID=T_CloseAllOpi(0,1);//按对价对期货账户清仓
body=T_CloseAllOpi( , )

[OpenSecs]
type=2
test=1
modifytime=2015-5-11
explanation=取开盘后经过的秒数
description=取开盘后经过的秒数。\r\n用法：\r\nOpenSecs("CODE")取CODE合约开盘后经过的秒数\r\n注：\r\n1、该函数返回当前本地时间距离开盘经过的秒数\r\n2、该函数返回值为距离开盘的自然时间，即秒数包含休盘时间\r\n3、该函数在合约闭盘后返回0\r\n\r\n例：\r\nVAR OpenSec; \r\nOpenSec=OpenSecs("m1509"); //定义一个变量OpenSec,OpenSec的值为豆粕1509开盘后经过的秒数。
body=OpenSecs()

[POW]
type=3
test=1
createtime=2015-7-27
explanation=求X的Y次幂
description=POW(X,Y):求X的Y次幂。\r\n\r\n注：\r\n1、当X<0时，且Y为小数的时候，函数不做计算，因为底数为负时，不能进行开方运算，此时返回0。\r\n2、X,Y可以为数值，也可以为变量。\r\n\r\n例1：\r\nVAR price,pow;\r\nVOID MAIN()\r\n{\r\nprice=Price("IF1509","New");\r\npow=POW(price,2);\r\nMessageOut(pow);//输出IF1509最新价的平方\r\n}\r\n\r\n例2：\r\nVAR price1,price2,price,pow;\r\nVOID MAIN()\r\n{\r\nprice1=Price("IF1509","Low");\r\nprice2=Price("IF1509","High");\r\nprice=price1-price2;\r\npow=POW(price,2.1);\r\nMessageOut(pow);//price是IF1509的最低价减最高价，如果price是负数时，输出值为0\r\n}
body=POW( , )

[Timer]
type=2
test=1
createtime=2015-8-7
explanation=返回委托发出到全成或撤单成功的时间
description=Timer(OrderID)：返回委托发出到全成或撤单成功的时间\r\n\r\n用法：\r\n计时器函数，根据委托唯一标识OrderID，从委托发出开始计时，返回到委托全成或撤单成功的时间，委托未完成时，返回委托发出到现在的秒数。OrderID(字符串)。\r\n\r\n例：\r\nVAR timer,BKID,KD,COND1;\r\nVOID MAIN()\r\n{\r\nKD=开仓条件;//定义开仓条件\r\ntimer=Timer(BKID);\r\nIF(KD && COND1==0 )\r\nBKID=T_Deal("m1509",0,0,0,0);//以对价买开1手豆粕1509\r\nCOND1=1;\r\n}\r\nMessageOut(timer);\r\n//进行计时，输出从委托发出到全成或撤单成功的秒数\r\n}
body=Timer()

[Counter]
type=2
test=1
createtime=2015-8-7
explanation=返回目标函数已经执行的次数
description=Counter("FuncName")：计数器函数，返回目标函数已经执行的次数，FuncName为目标函数名\r\n\r\n例：\r\nVAR counter,BKID,KD,COND1;\r\nVOID MAIN()\r\n{\r\nKD=开仓条件;//定义开仓条件\r\ncounter=Counter("T_Deal");//目标函数为T_Deal\r\nIF(KD && COND1==0 )\r\n{\r\nBKID=T_Deal("m1509",0,0,0,0);//以对价买开1手豆粕1509\r\nCOND1=1;\r\n}\r\nMessageOut(counter);\r\n//进行计数，输出T_Deal函数已经执行的次数\r\n}
body=Counter()


[F_SigTriggerPrice]
type=4
test=0
modifytime=2015-11-18
explanation=取当前信号发出时盘口对应的最新价格
description=取当前信号发出时盘口对应的最新价格。\r\n用法：\r\nAA.F_SigTriggerPrice() 取当前信号发出时盘口对应的最新价格。\r\n\r\n注：\r\n1.该函数前必须用AA.的形式来调用，其中AA为字符串变量或者模组名。该函数不能单独使用。\r\n2.数据合约和交易合约不相同时，取信号出现时交易合约盘口对应的最新价格。\r\n\r\n例：\r\nIF(AA.F_SigTriggerPrice()>3500) //如果当前信号发生时盘口对应的最新价格大于3500 
body=F_SigTriggerPrice()

[T_Deal1]
type=5
test=0
modifytime=2015-12-1
explanation=以指定价格类型发出委托
description=以指定价格类型发出委托。\r\n用法：\r\nT_Deal1(Code,bs,kp,vol,price),以指定价格类型发出委托，返回唯一委托标识OrderID(字符串)。\r\nCode(字符串):合约编码\r\nbs(整数0，1):0 买 1 卖 \r\nkp(整数0，1，2):0 开 1平 2平今 \r\nVol(整数)：下单手数\r\nPrice(必须为指定的价格类型):\r\nNEW_ORDER：最新价；PASSIVE_ORDER：排队价；ACTIVE_ORDER：对价；CMPETITV_ORDER：超价；LIMIT_ORDER市价,部分合约不支持市价指令，会提示该合约不支持市价指令。\r\n注：\r\n1、如果输入的价格为具体数值，或者其他非指定类型的变量，不会执行委托\r\n2、该函数不支持历史回测 \r\n例：\r\nVAR orderID=T_Deal1("m1601", 0, 0, 5, ACTIVE_ORDER); 发出委托：m1601 买开5手 对价委托
body=T_Deal1( , , , , )

[T_CancelAllOrder]
type=5
test=0
modifytime=2015-12-1
explanation=撤当前交易账号的所有挂单
description=撤当前交易账号的所有挂单。\r\n用法：\r\nT_CancelAllOrder(),撤当前交易账号的所有挂单，不返回委托标识 \r\n\r\n注：\r\n该函数不支持历史回测。\r\n例：\r\nGLOBAL_VAR TIME ,TIME1;\r\nVOID MAIN()\r\n{\r\nTIME1 = CurrentServerTime("m1601");\r\nTIME = Time("14:59:00");\r\nIF(TIME1 >= TIME)\r\n{\r\nT_CancelAllOrder();//时间大于145900，撤掉交易账号的所有挂单\r\n}\r\n}
body=T_CancelAllOrder()


[T_AllIsNoOrder]
type=1
test=0
modifytime=2015-12-1
explanation=判断当前账户是否为无挂单状态
description=判断当前账户是否为无挂单状态。\r\n用法：\r\nT_AllIsNoOrder(),判断当前账户是否为无挂单状态，如果没有挂单返回1，否则返回0 \r\n\r\n注：\r\n该函数不支持历史回测。\r\n例：\r\nIF(T_AllIsNoOrder()) //如果没有挂单
body=T_AllIsNoOrder()

[F_GetCallCode]
type=4
test=0
modifytime=2015-12-2
explanation=获取跨合约变量对应的合约名
description=获取跨合约变量对应的合约名。\r\n用法：\r\nMod.F_GetCallCode("变量名");,获取模组模型中跨周期、跨合约变量对应的合约名\r\n注：\r\n1、该函数前必须用Mod.的形式来调用，其中Mod为字符串变量或者模组名。该函数不能单独使用。\r\n2、模组加载的模型中#CALL、#CALL_PLUS编写的合约名称可以使用该函数获取 \r\n\r\n例：\r\n跨合约引用指标ZF:\r\nH1:HHV(H,10);\r\nL1:LLV(L,10);\r\nHH:(H1-L1)/L1;\r\n\r\n模组加载模型为：\r\n#CALL[1205,WHBXSF] AS VAR1\r\nHH1:VAR1.HH;\r\n#CALL[1285,WHBXSF] AS VAR2\r\nHH2:VAR2.HH;\r\n#CALL[1405,WHBXSF] AS VAR3\r\nHH3:VAR3.HH;\r\n\r\n盘口模型运行池中加载运行：\r\nGLOBAL_VAR code,i;\r\nGLOBAL_VAR MAXX,tmp;\r\nGLOBAL_VAR VARVALUE[3],TYPE2;\r\nGLOBAL_VAR VARNAME[3];\r\nVOID MAIN()\r\n{\r\n\r\n   Mod = "函数测试";\r\n   VARNAME[0] = "VAR1";\r\n   VARNAME[1] = "VAR2";\r\n   VARNAME[2] = "VAR3";\r\n   VARVALUE[0] = #Get(Mod,"HH1",0);\r\n   VARVALUE[1] = #Get(Mod,"HH2",0);\r\n   VARVALUE[2] = #Get(Mod,"HH3",0);\r\n   tmp = VARVALUE[0];\r\n   MAXX = 0;\r\n   FOR(i=1; i < 3; i=i+1)\r\n   {\r\n       IF(VARVALUE[i] > tmp)\r\n       {\r\n           tmp=VARVALUE[i];\r\n           MAXX=i;\r\n        }\r\n    }\r\n   code = Mod.F_GetCallCode(VARNAME[MAXX]);//取得指标值最大的合约\r\n\r\n}
body=F_GetCallCode()

[MAX1]
type=3
test=1
explanation=取最大值
description=MAX1(A1,...,A30) 在A1到A30中取最大值\r\n注：\r\n1、支持2-30个数值进行比较。\r\n2、A1...A30可以为数字也可以为变量\r\n例：\r\nMessageOut(MAX(Mod.F_High(1),Mod.F_High(2),Mod.F_High(3)));//输出模组中前3根K线中最高价的的最大值。(Mod需定义)
body=MAX1(,)

[F_SigCode]
type=4
test=0
modifytime=2014-08-05
explanation=取得当前信号的交易合约的合约编码
description=取得当前信号的交易合约的合约编码。\r\n用法：\r\nAA.F_SigCode()返回模组AA所发出信号的交易合约的合约编码(以字符串类型返回)\r\n\r\n注：\r\n1、该函数前必须用AA.的形式来调用，其中AA为字符串变量或者模组名。该函数不能单独使用。\r\n2、取得的如果为自动换月的模组的信号，信号为换月前合约上出现的，则该函数返回为前一主力合约的交易编码\r\n\r\n例：\r\nVAR DealCode;\r\nDealCode=AA.F_SigCode();  //变量DealCode的内容为模组AA当前信号交易合约的合约编码.
body=F_SigCode()


[T_BatchOrder]
type=5
test=1
explanation=发出多笔委托
description=发出多笔委托。\r\n用法：\r\nT_BatchOrder(Code,bs,kp,vol,price,offsetprice,num),发出多笔委托 Code(字符串):合约编码，bs(整数0，1):0 买 1 卖 ，kp(整数0，1，2):0 开 1平 2平今 Vol(整数)：下单手数，Price(整数或小数):下单价格，0为对价 offsetPrice为多少个最小变动单位，num是委托的次数，返回值为一个OrderID的数组\r\n\r\n例：\r\na = T_BatchOrder("IF1603",0,1,2,3010,-2,5);同时发出5笔委托：IF1603买平两手，阶梯价委托，委托价以3010为基准每次递减2个最小变动单位
body=T_BatchOrder( , , , , , , )

[T_DeleteOrderByPrice]
type=5
test=0
explanation=撤指定价位单
description=撤指定价位单。\r\n用法：\r\nT_DeleteOrderByPrice(code,price);撤掉code所有price价格的委托\r\n\r\n注：\r\n该函数不支持历史回测。\r\n\r\n例： \r\nb = T_DeleteOrderByPrice("IF1603",3010);//撤掉IF1603在3010价位上的所有委托
body=T_DeleteOrderByPrice( , )


[T_BuyProfitLoss1]
type=5
test=0
explanation=交易系统某合约的多头盯市浮盈
description=交易系统某合约的多头盯市浮盈\r\n用法：\r\nT_BuyProfitLoss1(code)返回交易系统合约code的多头盯市浮盈\r\n\r\n注：\r\n该函数不支持历史回测。\r\n例：\r\nVAR BuyEarn;\r\nBuyEarn=T_BuyProfitLoss1("SR605");// 定义一个变量BuyEarn,BuyEarn的值为交易系统合约SR605的多头盯市浮盈
body=T_BuyProfitLoss1()


[T_SellProfitLoss1]
type=5
test=0
explanation=交易系统某合约的空头盯市浮盈
description=交易系统某合约的空头盯市浮盈\r\n用法：\r\nT_SellProfitLoss1(code)返回交易系统合约code的空头盯市浮盈\r\n\r\n注：\r\n该函数不支持历史回测。\r\n例：\r\nVAR SellEarn;\r\nSellEarn=T_SellProfitLoss1("SR605");// 定义一个变量SellEarn,SellEarn的值为交易系统合约SR605的空头盯市浮盈
body=T_SellProfitLoss1()

[T_MarginRatio]
type=5
test=0
explanation=交易系统中某合约的保证金或保证金率
description=交易系统中某合约的保证金或保证金率\r\n\r\n用法：T_MarginRatio(Code，n),取交易系统中合约Code的保证金或保证金率,如果是国内期货合约，取保证金率，如果是外盘期货合约，取每手保证金\r\nn:买卖方向 0买 1卖\r\n\r\n注：\r\n1、如没有交易过该合约，第一次加载运行可能存在返回值为-1的情况\r\n2、实盘取值为账号交易该品种的实际的保证金率 即期货公司规定的标准\r\n3、该函数不支持历史回测。\r\n\r\n例：\r\nGLOBAL_VAR margin,code;\r\nVOID MAIN()\r\n{\r\ncode = "IF2009";\r\nIF(T_MarginRatio(code,0)<0)\r\n{\r\nRETURN;\r\n}\r\nELSE\r\nmargin = T_MarginRatio(code,0); \r\nMessageOut(margin); \r\n}
body=T_MarginRatio()

[SubStr]
type=2
test=1
explanation=截取字符串
description=截取字符串\r\n\r\n用法：\r\nSubStr(string,start,length);截取字符。string指定的要截取的字符串，start在字符串的何处开始，length指定要截取的字符串长度。有取品种名称的作用\r\n\r\n例：\r\nSubStr("SR605",0,2);截取前两个字符串，返回“SR”
body=SubStr(,,)

[MIN1]
type=3
test=1
explanation=取最小值
description=取最小值\r\nMIN1(A1,...,A30) 在A1到A30中取最小值\r\n注：\r\n1、支持2-30个数值进行比较。\r\n2、A1...A30可以为数字也可以为变量\r\n例：\r\nMessageOut(MIN1(Mod.F_High(1),Mod.F_High(2),Mod.F_High(3)));//输出模组中前3根K线中最高价的的最小值。(Mod需定义)
body=MIN1()


[FloatToStr]
type=2
test=1
explanation=保留小数位数
description=保留几位小数\r\n用法:\r\nFloatToStr（float,bit）float为浮点数，bit为保留小数位数\r\n\r\n例：\r\nVAR vPrice;\r\nVOID MAIN()\r\n{\r\n   vPrice = Price("8607","Open");\r\n   MessageOut(FloatToStr(vPrice,1));//保留一位小数取该合约开盘价\r\n}
body=FloatToStr()

[GetDecimal]
type=2
test=1
explanation=取得合约的小数位数
description=取得合约的小数位数\r\n用法：GetDecimal("CODE") 取CODE合约的小数位数\r\n\r\n例：\r\nVAR vCount;\r\nVOID MAIN()\r\n{\r\n   vCount = GetDecimal("8049");//取加币合约的小数位数\r\n   MessageOut(vCount);\r\n}
body=GetDecimal()

[F_IsIdle]
type=1
test=0
explanation=判断信号发出时是否满足IDLE条件
description=判断信号发出时是否满足IDLE条件\r\n用法：\r\nAA.F_IsIdle() 趋势模型中有IDLE函数时，判断信号发出时IDLE条件是否满足，返回1表示满足 0表示不满足 -1表示还未刷出过信号或未绑定模组等异常状态。\r\n注：\r\n1、该函数必须与AA.F_FreshSig()刷新信号函数同时使用。\r\n2、该函数前必须用AA.的形式来调用，其中AA为字符串变量或者模组名。该函数不能单独使用。\r\n\r\n例：\r\nVAR Modname;\r\nVAR N;\r\n\r\nVOID MAIN()\r\n{\r\n    Modname="DDD";\r\nIF (Modname.F_FreshSig() == 1) //如果当前信号是没有处理过的新信号	\r\n{\r\n	IF(Modname.F_IsIdle() == 1)//新信号满足IDLE条件\r\n	{\r\n		MessageOut("满足啦");\r\n	}\r\n}\r\n}
body=F_IsIdle()

[AL_GetName]
type=2
test=0
explanation=获取当前算法交易名称
description=获取当前算法交易名称\r\n用法：\r\nStgName = AL_GetName(); 获取当前算法交易名称\r\n\r\n例：\r\nVAR StgName; \r\nStgName=AL_GetName(); //定义一个变量StgName，StgName为当前算法交易的名称
body=AL_GetName()

[WriteToFile]
type=2
test=0
explanation=取合约字段值写入文件
description=取合约字段值写入文件\r\n\r\n用法：\r\nWriteToFile（文件名，Cod，"合约字段名"，N）；取当前算法交易文件中合约名Cod的合约字段值，取N位小数写入文件\r\n写入的文件存在根目录下的\Formula\ALInfo\"路径下的配置文件中，文件名为算法交易模型名称\r\n\r\n支持的合约字段如下：\r\n"AL_BuyAvgPrice" 多头持仓成本价\r\n"AL_SellAvgPrice" 空头持仓成本价\r\n"AL_BuyPosition" 多头持仓\r\n"AL_SellPosition" 空头持仓\r\n"AL_BuyRemainPosition" 多头可用持仓\r\n"AL_SellRemainPosition" 空头可用持仓\r\n"AL_BuyProfitLoss" 多头盈亏\r\n"AL_SellProfitLoss" 空头盈亏\r\n"AL_LastOffSetProfit" 最近一次的平仓盈亏\r\n"AL_OffSetProfit" 平仓盈亏\r\n\r\n例：\r\nGLOBAL_VAR FieldValue;\r\nGLOBAL_VAR StgName,Cod;\r\nGLOBAL_VAR BKID,ID;\r\nVOID MAIN()\r\n{\r\n   Cod="CLX6";\r\n   IF(ID==0)\r\n   {\r\n      StgName=AL_GetName();\r\n      FieldValue=ReadFromFile(StgName,"CLX6","AL_BuyAvgPrice");//读取当前算法交易文件中CLX6的多头持仓均价\r\n      MessageOut(FieldValue);\r\n      ID=1;\r\n   }\r\n   IF(CurrentTime()>Time("09:30:00") && ID==1)\r\n   {\r\n     BKID=T_Deal(Cod,0,0,1,0);   \r\n      ID=2;\r\n   }\r\n   IF(T_OrderState(BKID)==1 && ID==2)\r\n   {\r\n     WriteToFile(StgName,"CLX6","AL_BuyAvgPrice",3);//取当前算法交易文件中合约名CLX6的合约字段值，取3位小数写入文件\r\n      ID=3;\r\n   }\r\n}
body=WriteToFile()


[ReadFromFile]
type=2
test=0
explanation=读取文件中合约字段值
description=读取文件中合约字段值\r\n\r\n用法：\r\nReadFromFile（文件名，Cod，"合约字段名"）；读取算法交易文件中合约名Cod的合约字段值\r\n\r\n支持的合约字段如下：\r\n"AL_BuyAvgPrice" 多头持仓成本价\r\n"AL_SellAvgPrice" 空头持仓成本价\r\n"AL_BuyPosition" 多头持仓\r\n"AL_SellPosition" 空头持仓\r\n"AL_BuyRemainPosition" 多头可用持仓\r\n"AL_SellRemainPosition" 空头可用持仓\r\n"AL_BuyProfitLoss" 多头盈亏\r\n"AL_SellProfitLoss" 空头盈亏\r\n"AL_LastOffSetProfit" 最近一次的平仓盈亏\r\n"AL_OffSetProfit" 平仓盈亏\r\n\r\n例：\r\nGLOBAL_VAR FieldValue;\r\nGLOBAL_VAR StgName,Cod;\r\nGLOBAL_VAR BKID,ID;\r\nVOID MAIN()\r\n{\r\n   Cod="CLX6";\r\n   IF(ID==0)\r\n   {\r\n      StgName=AL_GetName();\r\n      FieldValue=ReadFromFile(StgName,"CLX6","AL_BuyAvgPrice");//读取当前算法交易文件中CLX6的多头持仓均价\r\n      MessageOut(FieldValue);\r\n      ID=1;\r\n   }\r\n   IF(CurrentTime()>Time("09:30:00") && ID==1)\r\n   {\r\n     BKID=T_Deal(Cod,0,0,1,0);   \r\n      ID=2;\r\n   }\r\n   IF(T_OrderState(BKID)==1 && ID==2)\r\n   {\r\n     WriteToFile(StgName,"CLX6","AL_BuyAvgPrice",3);//取当前算法交易文件中合约名CLX6的合约字段值，取3位小数写入文件\r\n      ID=3;\r\n   }\r\n}
body=ReadFromFile()


[CheckPosition]
type=1
test=0
explanation=判断是否正在查询持仓
description=判断是否正在查询持仓\r\n\r\n用法：\r\nCheckPosition,判断是否正在查询持仓。返回值含义：正在查询持仓返回1（此时算法交易模型的持仓状态不可用），非正在查询返回0，其他异常情况返回-1。\r\n\r\n注：\r\n该函数不支持历史回测。\r\n\r\n例：\r\nGLOBAL_VAR BKID,ID;\r\nGLOBAL_VAR Cod;\r\nVOID MAIN()\r\n{\r\n   Cod="au1706";\r\n   IF(ID==0  && CurrentTime()>Time("09:30:00") )\r\n   {\r\n     BKID=T_Deal(Cod,0,0,1,0); \r\n     ID=1;\r\n   }\r\n   IF(T_OrderState(BKID)==1 && CheckPosition()==0 && ID==1)//委托成交并且非正在查询持仓状态时\r\n   {\r\n     MessageOut(AL_BuyPosition(Cod));\r\n   }\r\n}
body=CheckPosition()


[T_TodayBuyPosition]
type=5
test=0
createtime=2017-04-24
explanation=交易系统某合约多头今仓
description=交易系统某合约多头今仓。\r\n用法：\r\nT_TodayBuyPosition(Code); 返回交易系统中合约Code的多头今仓,Code为某合约的合约代码。\r\n\r\n注：\r\n该函数不支持回测。\r\n例：\r\nVAR TodayBuyVol;\r\nTodayBuyVol=T_TodayBuyPosition("m1709"); //TodayBuyVol为交易系统中合约代码为m1709的合约的多头今仓。
body=T_TodayBuyPosition( )


[T_TodaySellPosition]
type=5
test=0
createtime=2017-04-24
explanation=交易系统某合约空头今仓
description=交易系统某合约空头今仓。\r\n用法：\r\nT_TodaySellPosition(Code); 返回交易系统中合约Code的空头今仓,Code为某合约的合约代码。\r\n\r\n注：\r\n该函数不支持回测。\r\n例：\r\nVAR TodaySellVol;\r\nTodaySellVol=T_TodaySellPosition("m1709"); //TodaySellVol为交易系统中合约代码为m1709的合约的空头今仓。
body=T_TodaySellPosition( )


[T_TodayBuyRemainPosition]
type=5
test=0
createtime=2017-04-24
explanation=交易系统某合约多头可用今仓
description=交易系统某合约多头可用今仓。\r\n用法：\r\nT_TodayBuyRemainPosition(Code); 返回交易系统中合约Code的多头可用今仓,Code为某合约的合约代码。\r\n\r\n注：\r\n该函数不支持回测。\r\n例：\r\nVAR TodayBuyRemainVol;\r\nTodayBuyRemainVol=T_TodayBuyRemainPosition("m1709"); //TodayBuyRemainVol为交易系统中合约代码为m1709的合约的多头可用今仓。
body=T_TodayBuyRemainPosition( )


[T_TodaySellRemainPosition]
type=5
test=0
createtime=2017-04-24
explanation=交易系统某合约空头可用今仓
description=交易系统某合约空头可用今仓。\r\n用法：\r\nT_TodaySellRemainPosition(Code); 返回交易系统中合约Code的空头可用今仓,Code为某合约的合约代码。\r\n\r\n注：\r\n该函数不支持回测。\r\n例：\r\nVAR TodaySellRemainVol;\r\nTodaySellRemainVol=T_TodaySellRemainPosition("m1709"); //TodaySellRemainVol为交易系统中合约代码为m1709的合约的空头可用今仓。
body=T_TodaySellRemainPosition( )


[GetMainCodeName]
type=0
test=0
createtime=2017-05-25
explanation=用于获取合约的主力合约
description=用于获取合约的主力合约。\r\n用法：\r\nGetMainCodeName('Code') 用于获取Code合约的主力合约(以字符串类型返回)\r\n\r\n注：\r\n1、该函数参数位置支持写入指数、主连或主指合约，取其对应的主力合约。\r\n2、如果写入的合约没有对应的主力合约，则该函数返回空值。\r\n\r\n例：\r\nVAR CodeName;\r\nVAR ModName;\r\nVAR N;\r\nVOID MAIN()\r\n{\r\n   CodeName = GetMainCodeName("沪铜主连");\r\n   N = 1;\r\n   IF (ModName.F_FreshSig() == 1)\r\n   {\r\n      IF (ModName.F_Sig() == BK)\r\n      {\r\n         T_Deal(GetMainCodeName("沪铜主连"),0,0,N,0);\r\n         MessageOut(GetMainCodeName("沪铜主连"));\r\n      }\r\n   }\r\n}\r\n//如果模组新信号是BK，获取沪铜主连的主力合约开仓
body=GetMainCodeName()


[StrToFloat]
type=2
test=0
explanation=字符串转换为数值
description=字符串转换为数值。\r\n用法：\r\nStrToFloat(Str) 把字符串Str转换为数值。\r\n例：\r\nMessageOut(StrToFloat(DateToStr(CurrentTime()))); //以数值类型返回当前日期
body=StrToFloat()


[T_BuyOpiAvgPrice]
type=5
test=0
explanation=交易系统某合约多头持仓均价
description=交易系统某合约多头持仓均价。\r\n用法：T_BuyOpiAvgPrice(Code)返回交易系统合约Code的多头持仓均价,Code为某合约合约代码。\r\n\r\n注：\r\n1、股票合约返回成交价（不包含手续费成本）。\r\n2、该函数不支持回测。\r\n例：\r\nVAR BuyPrice; BuyPrice=T_BuyOpiAvgPrice("m1009");// 定义一个变量BuyPrice,BuyPrice的值为交易系统合约m1009多头持仓均价
body=T_BuyOpiAvgPrice()


[T_GetContractLimitVol]
type=5
explanation=交易系统某合约的大单手数
description=交易系统某合约的大单手数。\r\n用法：T_GetContractLimitVol(Code)返回交易系统合约Code的大单手数,Code为某合约合约代码。\r\n\r\n注：\r\n通过算法交易模型绑定的交易账号获取，只对国内期货有效。\r\n\r\n例：\r\nVAR N;\r\nVOID MAIN()\r\n{\r\n	N=T_GetContractLimitVol("m1909");// 定义一个变量N,N的值为交易系统合约m1909的大单手数\r\n}
body=T_GetContractLimitVol()


[T_SellOpiAvgPrice]
type=5
test=0
explanation=交易系统某合约空头持仓均价
description=交易系统某合约空头持仓均价。\r\n用法：T_SellOpiAvgPrice(Code)返回交易系统合约Code的空头持仓均价,Code为某合约合约代码。\r\n\r\n注：\r\n该函数不支持回测。\r\n例：\r\nVAR SellPrice; SellPrice=T_SellOpiAvgPrice("m1009");// 定义一个变量SellPrice,SellPrice的值为交易系统合约m1009空头持仓均价
body=T_SellOpiAvgPrice()


[T_ProfitLoss]
type=5
test=0
explanation=返回交易系统的盯市浮盈
description=T_ProfitLoss 返回交易系统中的盯市浮盈。\r\n此函数为系统封装函数。\r\n\r\n用法：\r\nT_ProfitLoss(Type) 返回交易系统中的盯市浮盈。\r\n参数Type可写入指定类型，0为内盘，1为外盘，2为股票。\r\n\r\n\r\n注：\r\n1、返回值为浮点数，数值型。\r\n2、不能使用于历史测试，仅适用于实时行情交易。\r\n\r\n例：\r\nVOID MAIN()\r\n{\r\n   MessageOut(T_ProfitLoss(0));//取得当前账户的盯市浮盈\r\n}
body=T_ProfitLoss()


[QuotState]
type=1
test=0
explanation=判断合约是否收到动态行情
description=判断合约是否收到动态行情\r\n\r\n用法：\r\nQuotState("Code") 判断Code合约是否收到动态行情。当收到动态行情时返回1；其他情况返回0。\r\n\r\n注：\r\n1、用于判断是否收到动态行情，收到动态行情后才可以正常进行委托。\r\n2、该函数进行判断时会主动申请合约动态行情。\r\n\r\n例：\r\nGLOBAL_VAR BKID,ID;\r\nGLOBAL_VAR Cod;\r\nVOID MAIN()\r\n{\r\n   Cod="au1706";\r\n   IF(QuotState(Cod) == 1)//判断是否接收到动态行情\r\n   {\r\n      IF(ID==0  && CurrentTime()>Time("09:30:00") )\r\n      {\r\n        BKID=T_Deal(Cod,0,0,1,0); \r\n        ID=1;\r\n      }\r\n      IF(T_OrderState(BKID)==1 && CheckPosition()==0 && ID==1)//委托成交并且非正在查询持仓状态时\r\n      {\r\n        MessageOut(AL_BuyPosition(Cod));\r\n      }\r\n   }\r\n}
body=QuotState


[WritePrivateProfileString]
type=2
test=1
explanation=写入数据到指定的.ini文件
description=写入数据到指定的.ini文件\r\n\r\n用法：\r\nWritePrivateProfileString(String KeyWord,String Item,String Value,String Address) 写入数据到指定的.ini文件。\r\nKeyWord 文件写入位置的关键字\r\nItem 储存值的项目名称\r\nValue 写入的数据\r\nAddress 储存数据的文件名\r\n\r\n注：\r\n1、所有参数均为字符串类型。\r\n2、该函数返回0表示写入数据失败；返回值非0表示写入数据成功。\r\n3、文件名不支持变量，需要用双引号标注，不支持写入/\等符号。\r\n4、文件不支持指定路径，文件存储在环境\Formula\PrivateProfile文件下，这个文件夹不存在会自动创建。\r\n\r\n例：\r\nVAR str;\r\nVOID MAIN()\r\n{\r\n   WritePrivateProfileString("最新价","布伦特",FloatToStr(Price("BRNU9", "New"),2),"New");\r\n   str = GetPrivateProfileString("最新价","布伦特",Itoa(0),"New");\r\nMessageOut(str);\r\n} 
body=WritePrivateProfileString()

[GetPrivateProfileString]
type=2
test=1
explanation=读取数据从指定的.ini文件
description=读取数据从指定的.ini文件\r\n\r\n用法：\r\nGetPrivateProfileString(String KeyWord,String Item,String DefaultValue,String Address) 读取数据从指定的.ini文件。\r\nKeyWord 文件读取位置的关键字\r\nItem 读取的项目名称\r\nDefaultValue 默认值\r\nAddress 读取数据的文件名称\r\n\r\n注：\r\n1、所有参数均为字符串类型。\r\n2、文件名不支持变量，需要用双引号标注，不支持写入"\","/"等符号。\r\n3、文件不支持指定路径，在环境\Formula\PrivateProfile文件下读取数据。\r\n\r\n例：\r\nVAR str;\r\nVOID MAIN()\r\n{\r\n   WritePrivateProfileString("最新价","布伦特",FloatToStr(Price("BRNU9", "New"),2),"New");\r\n   str = GetPrivateProfileString("最新价","布伦特",Itoa(0),"New");\r\nMessageOut(str);\r\n} 
body=GetPrivateProfileString()

[GetSectionEndTime]
type=2
test=1
explanation=取得某合约第几个小节的结束时间
description=取得某合约第几个小节的结束时间\r\n\r\n用法：GetSectionEndTime("Code",N);取CODE合约第n个小节的结束时间。\r\n参数CODE 支持写文华码或者合约代码;\r\n参数N，表示第几个小节(交易时间段)。\r\n以沪金合约为例：\r\nN=1,第一小节为21:00到次日2点30,小节结束时间为02:30:00；N=2,第二次小节为上午9:00-10:15,小节结束时间为10:15:00；N=3,第三小节为上午10:30-11:30,小节结束时间为11:30:00,N=4,第四小节为13:30-15:00,小节结束时间为15:00:00\r\n\r\n注：\r\n1、该函数返回的结束时间总秒数是从1970年1月1日开始计算，具体时间需要与TimeToStr函数连用转换为字符串查看\r\n2、计算结果为0时，转换后默认取到时间是08:00:00。\r\n\r\n例：\r\nVAR str,str1,NOW;\r\nGLOBAL_VAR FLG,BKID;\r\nVOID MAIN()\r\n{\r\n    NOW=CurrentTime();\r\n    str=GetSectionEndTime("1118",4);//取文华码为1118合约的第四小节的结束时间\r\n    IF(FLG==0&&(str-NOW)<=3600)\r\n      {\r\n      BKID=T_Deal("m2001", 0, 0, 1, 0);\r\n      FLG=1;\r\n    }\r\n    str1=str-NOW;\r\n    MessageOut("输出距离小节结束秒数"+ str1);\r\n}
body=GetSectionEndTime(,)
